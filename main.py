# biggest non-stop project ive done took about a month had about half done may 13-14, and so before may by a bit 
print("Created by YATA Systems")
import pygame
import sys
import random
import math
import smtplib
# for website thing

pygame.init()


# classes
class Hands:
    # players = [0]

    # dealer_cards = []

    def __init__(self):
        self.variables = {"cards": [], "total": 0, "num_aces": 0, "status": "in_play", "card_num": 0, "bet": 0,
                          "judged": False, "ins_bet": 0}

    def __getitem__(self, item):
        return self.variables[item]

    def __setitem__(self, key, value):
        # if key == "cards":
        # self.variables[key] = f"{value} "
        if key == "cards":
            self.variables[key] = value
        if key == "total":
            self.variables[key] = value
        if key == "num_aces":
            self.variables[key] = value
        if key == "status":
            self.variables[key] = value
        if key == "card_num":
            self.variables[key] = value
        if key == "bet":
            self.variables[key] = value
        if key == "judged":
            self.variables[key] = value
        if key == "ins_bet":
            self.variables[key] = value


class Player:
    ds = "start"
    total_players = 0
    player_list = []
    playing_list = []
    t = 0
    show_dealer = False
    continue_game = True
    next_game = True
    total_busts = 0
    graded = False

    def __init__(self):
        self.variables = {"hand-0": Hands(), "hand-1": Hands(), "hand-2": Hands(), "hand-3": Hands(), "num_busts": 0,
                          "num_hands": 1, "hand": [0], "balance": 0, "start_balance": 0, "name": "PLAYER", "bet": 0,
                          "pev_bet": 0,
                          "pev_chip": "", "total_cards": [], "total_num_hands": 1}

    def __getitem__(self, item):
        return self.variables[item]

    def __setitem__(self, key, value):
        if key == "hand-0":
            self.variables[key] = value
        if key == "hand-1":
            self.variables[key] = value
        if key == "hand-2":
            self.variables[key] = value
        if key == "hand-3":
            self.variables[key] = value
        if key == "num_busts":
            self.variables[key] = value
        if key == "num_hands":
            self.variables[key] = value
        if key == "hand":
            self.variables[key] = (value)
        if key == "balance":
            self.variables[key] = value
        if key == "name":
            self.variables[key] = value
        if key == "bet":
            self.variables[key] = value
        if key == "pev_bet":
            self.variables[key] = value
        if key == "pev_chip":
            self.variables[key] = value
        if key == "total_cards":
            self.variables[key] = (value)
        if key == "total_num_hands":
            self.variables[key] = value


class Time:
    start_showing = False
    done = False

def send_email(receiver, subject, content):
    # now you can play with your code. Letâ€™s define the SMTP server separately here:
    port = 587
    smtp_server = "smtp.gmail.com"
    login = "no password"  # paste your login generated by Mailtrap
    password = "no passowrd"  # paste your password generated by Mailtrap

    gmail_user = login
    gmail_pwd = password
    FROM = login
    TO = receiver if type(receiver) is list else [receiver]
    SUBJECT = subject
    TEXT = content

    # Prepare actual message
    message = """\From: %s\nTo: %s\nSubject: %s\n\n%s
        """ % (FROM, ", ".join(TO), SUBJECT, TEXT)
    try:
        server = smtplib.SMTP(smtp_server, port)
        server.ehlo()
        server.starttls()
        server.login(gmail_user, gmail_pwd)
        server.sendmail(FROM, TO, message)
        server.close()
        print('successfully sent the mail')
        return True
    except:
        print("failed to send mail")
        return False
# all functions
# logic functions

# functions fro reading and writing
def add_value(old_value, new_value):
    if str(new_value).isdigit() and str(old_value).isdigit():
        old_num = eval(old_value)
        #print(str(int(old_num) + int(new_value)), type(str(int(old_num) + int(new_value))))
        return str(int(old_num) + int(new_value))
    else:
        return new_value


def add_data(the_file, data, spot, user_line):
    with open(the_file, 'r') as file:
        all_text = file.readlines()
        user_name = all_text[user_line][:all_text[user_line].index("|") + 2]
        line_list = all_text[user_line][all_text[user_line].index("|") + 2:-1].split(",")
        line_list[spot] = str(add_value(line_list[spot], data))
        #print(line_list)
        line_str = ','.join(line_list)
        new_line = user_name + line_str + "\n"
        with open(the_file, 'w') as file_w:
            for idx, obj in enumerate(all_text):
                if idx == user_line:
                    file_w.write(new_line)
                else:
                    file_w.write(obj)


def get_data(the_file, spot, user_line):
    with open(the_file, 'r') as file:
        all_text = file.readlines()
        line_list = all_text[user_line][all_text[user_line].index("|") + 2:-1].split(",")
        return int(line_list[spot]) if line_list[spot].isdigit() else line_list[spot]


# gets card value
def get_pure_value(name):
    return eval(name[0]) if name[0] in ['2', '3', '4', '5', '6', '7', '8', '9'] else 10 if name[0] != 'A' else 11


def get_value(name, hand, list1):
    value = eval(name[0]) if name[0] in ['2', '3', '4', '5', '6', '7', '8', '9'] else 10
    if name[0] in ['A']:
        value = 1 if hand["total"] + 11 > 21 else 11
        hand["num_aces"] += 1 if value == 11 else 0
    hand["total"] += value
    while True:
        if hand["total"] < 22:
            break
        elif hand["total"] > 21 and hand["num_aces"] > 0:
            hand["total"] -= 10
            hand["num_aces"] -= 1
        else:
            break
    del list1[0]


# makes the deck
def make_52():
    decks = get_data(SETTINGS, 2, 0)
    suit_list = ['Hearts', 'Spades', 'Diamonds', 'Clubs']
    face_list = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', 'O']
    end_list = []
    for t in range(decks):
        for i in range(4):
            for k in range(13):
                end_list.append(f"{face_list[k]} {suit_list[i]}")
    random.shuffle(end_list)
    # print(len(end_list))

    # end_list.remove("A Hearts")
    # end_list.remove("10 Clubs")
    # end_list.remove("A Spades")
    # end_list.remove("10 Diamonds")
    '''
    end_list.insert(0, "10 Hearts")

    #end_list.remove("A Hearts")
    end_list.insert(0, "10 Hearts")
    end_list.insert(0, "10 Diamonds")
    end_list.insert(0, "A Spades")
    end_list.insert(0, "10 Clubs")
    
    end_list.remove("10 Hearts")
    end_list.remove("10 Clubs")
    end_list.remove("10 Spades")
    end_list.remove("10 Diamonds")
    end_list.insert(0, "10 Hearts")

    end_list.remove("A Hearts")
    end_list.insert(0, "A Hearts")
    end_list.insert(0, "10 Diamonds")
    end_list.insert(0, "10 Clubs")
    end_list.insert(0, "10 Spades")

    end_list.remove("2 Hearts")
    end_list.insert(0, "2 Hearts")
    end_list.remove("2 Diamonds")
    end_list.insert(0, "2 Diamonds")
    '''
    return end_list


# add one card to the user
def add_card(hand, list1):
    split_card = list1[0].split()
    add_str = [split_card[0], split_card[1]]
    hand["cards"].append(add_str)
    hand["card_num"] += 1
    return list1[0]


# checks if bust bj ot if you got 21
def check_hand(hand, what, user):
    key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5, "$lost": 6, "putin": 7,
           "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
    if what == "player":
        if hand["total"] > 21:
            hand["status"] = "bust"
            if what == "player":
                user["num_busts"] += 1
                Player.total_busts += 1
            finish = False
        elif hand["total"] == 21 and hand["card_num"] == 2 and user["total_num_hands"] == 1:
            hand["status"] = "bj"
            add_data(ACCOUNTS, 1, key["bj"], get_line(ACCOUNTS, user["name"]))
            # hand["bet"] += hand["bet"]//2
            finish = False
        elif hand["total"] == 21:
            hand["status"] = "21"
            finish = False
        else:
            finish = True
        if not finish:
            return False
        else:
            return True
    #        str_list = {"17": f"Got {fv}", "hit": "Hitting", "bust": "Bust", "above": "Above 17", "bj": "BlackJack"}

    elif Player.show_dealer:
        chv, fv = hand["total"], get_data(SETTINGS, 0, 3)
        hand["status"] = "bj" if chv == 21 and hand[
            "card_num"] == 2 else "bust" if chv > 21 else "17" if chv == fv else "above" if fv < chv <= 21 else "Got 21" if chv == 21 and \
                                                                                                                            hand[
                                                                                                                                "card_num"] > 2 else "in_play"
        return True if hand["status"] == "hit" else False


# finds what you can do
def find_options(hand, dealer, user):
    total_bet = 0
    for i in range(user["total_num_hands"]):
        total_bet += user[f'hand-{i}']["bet"]
    end_list = ['hit', 'stand']
    # p_card = decode_cards(hand)
    # d_card = decode_cards(dealer)
    # print(hand)
    p_card = hand["cards"]
    d_card = dealer["cards"]
    if (hand["card_num"] == 2 and user["total_num_hands"] < 4) and (
            get_pure_value(p_card[0][0]) == get_pure_value(p_card[1][0]) and hand["bet"] + total_bet <= user[
        "balance"]):
        option = "split"
        end_list.append(option)
    if hand["card_num"] == 2 and hand["bet"] + total_bet <= user["balance"]:
        option = "double"
        end_list.append(option)
    if hand["card_num"] == 2:
        option = "surrender"
        end_list.append(option)
    if hand["card_num"] == 2 and d_card[1][0] == 'A' and get_data(SETTINGS, 2, 3) == 'on' and hand[
        "bet"] // 2 + total_bet <= user["balance"] and hand["ins_bet"] == 0:
        option = "insurance"
        end_list.append(option)

    # print(end_list, p_card)
    return end_list


def get_outcome(button, button_list, hand, hand2, list1, cur_user):
    choice = button_list[button[0]].lower()
    # choice = button
    # print(choice, "choice")
    # print(hand["bet"])
    # print(cur_user["hand"])
    if choice == 'hit':
        get_value(add_card(hand, list1), hand, list1)
        return True
    if choice == 'stand':
        hand["status"] = "stand"
        check_hand(hand, "end", cur_user)
        # finish_hand(cur_user)
        return False
    if choice == 'split':
        split_cards(hand, hand2, list1, cur_user)
        return True
    if choice == 'surrender':
        hand["status"] = "surrender"
        # hand["bet"] -= round(hand["bet"]/2) if type(hand["bet"]/2) != int else hand["bet"]/2
        #hand["bet"] //= 2 # flag surrender
        check_hand(hand, "end", cur_user)
        # finish_hand(cur_user)
        return False
    if choice == 'double':
        hand["status"] = "double"
        hand["bet"] *= 2
        get_value(add_card(hand, list1), hand, list1)
        # check_hand(hand, "end", cur_user)
        # finish_hand(cur_user)
        return False
    if choice == 'insurance':
        hand["status"] = "at_hand"
        hand["ins_bet"] = hand["bet"] // 2
        return True
    # return hand["bet"]


# resets a hand
def reset(hand):
    hand["cards"] = []
    hand["total"] = 0
    hand["num_aces"] = 0
    hand["status"] = "in_play"
    hand["card_num"] = 0


# splits cards
def split_cards(hand, hand2, list1, user):
    user["num_hands"] += 1
    user["total_num_hands"] += 1
    user["hand"].append(user["total_num_hands"] - 1)
    hand2["bet"] = hand["bet"]
    cards = hand["cards"]
    card1 = f"{cards[0][0]} {cards[0][1]}"
    card2 = f"{cards[1][0]} {cards[1][1]}"
    reset(hand)
    list1.insert(0, card1)
    get_value(add_card(hand, list1), hand, list1)
    get_value(add_card(hand, list1), hand, list1)
    list1.insert(0, card2)
    get_value(add_card(hand2, list1), hand2, list1)
    get_value(add_card(hand2, list1), hand2, list1)


# finishes the hand
def finish_hand(user):
    user["hand"].remove(user["hand"][-1])
    user["num_hands"] -= 1
    # pygame.time.wait(2500)


# reshuffles the cards
def reshuffle(card_list):
    fpsClock = pygame.time.Clock()
    fps = 120
    fps_count = 0
    seconds_count = 0
    wait_time = 6
    cut_seen = True
    shuffle_deck = make_52()
    shuffle_card = random.choice(shuffle_deck)
    shuffle_angle = 0
    end = False
    if cut_seen:
        pygame.draw.rect(screen, GREEN, [0, 0, WIDTH, HEIGHT])
        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN * 5)
        text = smallfont.render('SHUFFLING', True, BLACK)
        text_rect = text.get_rect(center=((WIDTH) // 2, (HEIGHT) // 2))
        screen.blit(text, (MARGIN, text_rect[1]))
        while not end:
            shuffle_card = random.choice(shuffle_deck)
            fps_count += 1
            if fps_count >= fps / 2:
                seconds_count += .5
                fps_count = 0
            if seconds_count >= wait_time or end is True or get_data(SETTINGS, 4, 3) == 'off':
                # seconds_count = 0
                break
            for ev in pygame.event.get():
                # mouse = pygame.mouse.get_pos()
                if ev.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if ev.type == pygame.MOUSEBUTTONDOWN:
                    end = True
            shuffle_angle = display_cool_card(shuffle_card, shuffle_angle)
            pygame.display.update()
            fpsClock.tick(fps)
        pygame.draw.rect(screen, GREEN, [0, 0, WIDTH, HEIGHT])
    card_list = make_52()
    return card_list





def get_list_num():
    for i in range(1, 6):
        if i not in Player.player_list:
            return i

def get_line(the_file,name):
    with open(the_file, 'r') as file:
        all_text = file.readlines()
        for count, line in enumerate(all_text):
            if line[:line.index("|")] == name:
                return count
        return False
def reset_account(name):
    line = get_line(ACCOUNTS, name)
    for i in range(2, 12):
        add_data(ACCOUNTS, '', i, line)
        add_data(ACCOUNTS, 0, i, line)
# add or del playe from user list
#name| nickname,passowrd,email,balance,total_games,+-,$won,$lost,putin,wins,losses,pushes,bj
def del_add_player(what, the_list, name_list, name):
    key = {"password" : 0, "email" : 1,"balance" : 2, "total_games":3,"+-":4,"$won":5,"$lost":6,"putin":7,"wins":8,"losses":9,"pushes":10,"bj":11}
    if what == "guest" or  what == "add":
        # print(len(the_list))
        num = get_list_num()
        the_list[f"user_{num}"] = Player()
        Player.player_list.append(num)
        Player.total_players += 1
        if what == "guest":

            the_list[f"user_{num}"]["balance"] = get_data(SETTINGS, 1, 1)
            the_list[f"user_{num}"]["name"] = "PLAYER "+str(Player.player_list[-1])
            add_data(ACCOUNTS, get_data(SETTINGS, 1, 1), key["balance"], get_line(ACCOUNTS, name))
            add_data(ACCOUNTS, get_data(SETTINGS, 1, 1), key["putin"], get_line(ACCOUNTS, name))
            #name_list[f"user_{num}"] = name
        else:
            the_list[f"user_{num}"]["balance"] = get_data(ACCOUNTS, key["balance"], get_line(ACCOUNTS, name))
            #name_list[f"user_{num}"] = name
            the_list[f"user_{num}"]["name"] = name
    elif what == "add_deal":
        the_list[f"user_{0}"] = Player()
    else:
        if name == "player":
            print(the_list[f"user_{what}"]["name"])
            reset_account(the_list[f"user_{what}"]["name"])
        del the_list[f"user_{what}"]
        #del name_list[f"user_{what}"]
        Player.player_list.remove(what)
        Player.total_players -= 1



# makes the dealer
def make_dealer(user_dealer, card_list):
    dealer = user_dealer["hand-0"]
    dealer["cards"] = []
    pev_card = ""
    user_dealer["num_hands"] = 1
    for i in range(2):
        current_card = add_card(dealer, card_list)
        get_value(current_card, dealer, card_list)
        check_hand(dealer, "dealer", user_dealer)
    return dealer


def deal_cards(player_list, card_list):
    # print(player_list)
    for i in range(len(Player.playing_list) + 1):
        t = Player.playing_list[i - 1] if i != 0 else 0
        cur_hand = player_list[f"user_{t}"]["hand-0"]
        cur_hand["bet"] = player_list[f"user_{t}"]["bet"]
        player_list[f"user_{t}"]["balance"] = player_list[f"user_{t}"]["balance"] + cur_hand["bet"]
        while cur_hand["card_num"] < 2:
            get_value(add_card(cur_hand, card_list), cur_hand, card_list)
            # print(cur_hand["card_num"])
        # print(cur_hand["cards"])
        # print(cur_hand["card_num"])


def judge_hand(cur_hand, dealer_hand, user):
    # return "Lost"
    key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5, "$lost": 6, "putin": 7,
           "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
    og_bet = cur_hand["bet"]
    if cur_hand["judged"] is False:
        add_data(ACCOUNTS, 1, key["total_games"], get_line(ACCOUNTS, user["name"]))
        cur_hand["judged"] = True
        chv, dhv = cur_hand["total"], dealer_hand["total"]
        if dealer_hand["status"] == 'bj' and cur_hand["ins_bet"] != 0:
            print(cur_hand["bet"], cur_hand["ins_bet"])
            cur_hand["bet"] += cur_hand["ins_bet"] * 3
            #add_data(ACCOUNTS, 1, key["wins"], get_line(ACCOUNTS, user["name"]))
        if cur_hand["ins_bet"] > 0 and dealer_hand["status"] != 'bj':
            print(cur_hand["bet"], cur_hand["ins_bet"])
            cur_hand["bet"] -= cur_hand["ins_bet"]
        if cur_hand["status"] == 'bj' and dealer_hand["status"] != 'bj':
            cur_hand["bet"] += cur_hand["bet"] // 2
            add_data(ACCOUNTS, 1, key["wins"], get_line(ACCOUNTS, user["name"]))
            return "WON"
        elif cur_hand["status"] == 'bj' and dealer_hand["status"] == 'bj':
            cur_hand["bet"] = 0
            add_data(ACCOUNTS, 1, key["pushes"], get_line(ACCOUNTS, user["name"]))
            return "PUSH"
        elif dealer_hand["status"] == 'bj':
            cur_hand["bet"] = cur_hand["bet"] - og_bet * 2
            add_data(ACCOUNTS, 1, key["losses"], get_line(ACCOUNTS, user["name"]))
            return "LOST"
        if cur_hand["status"] == "surrender":
            cur_hand["bet"] = -cur_hand["bet"] // 2
            # print(cur_hand["bet"], "bet")
            add_data(ACCOUNTS, 1, key["losses"], get_line(ACCOUNTS, user["name"]))
            return "LOST"
        if chv > 21 or (chv < dhv and dhv < 22) or cur_hand["status"] == "surrender":
            cur_hand["bet"] = -cur_hand["bet"]
            add_data(ACCOUNTS, 1, key["losses"], get_line(ACCOUNTS, user["name"]))
            # print(cur_hand["bet"],"bet")
            return "LOST"

        if (chv > dhv or dhv > 21) and chv < 22:
            # print(cur_hand["bet"], "bet")
            add_data(ACCOUNTS, 1, key["wins"], get_line(ACCOUNTS, user["name"]))
            return "WON"
        if chv == dhv and chv < 22 > dhv:
            cur_hand["bet"] = 0
            add_data(ACCOUNTS, 1, key["pushes"], get_line(ACCOUNTS, user["name"]))
            # print(cur_hand["bet"], "bet")
            return "PUSH"
    else:
        chv, dhv = cur_hand["total"], dealer_hand["total"]
        chv, dhv = cur_hand["total"], dealer_hand["total"]
        if cur_hand["status"] == 'bj' and dealer_hand["status"] != 'bj':
            return "WON"
        elif cur_hand["status"] == 'bj' and dealer_hand["status"] == 'bj':
            return "PUSH"
        if cur_hand["status"] == "surrender":
            return "LOST"
        if chv > 21 or (chv < dhv and dhv < 22) or cur_hand["status"] == "surrender":
            return "LOST"
        if (chv > dhv or dhv > 21) and chv < 22:
            return "WON"
        if chv == dhv and chv < 21 > dhv:
            return "PUSH"
    return "LOST"


# gui functions ========================================================================================================


# test functions
def devide_screen(lines, h_or_v, lw):
    xx1 = WIDTH / lines if h_or_v == 'v' else 0
    yy1 = HEIGHT / lines if h_or_v == 'h' else 0
    xx2 = WIDTH / lines if h_or_v == 'v' else WIDTH
    yy2 = HEIGHT / lines if h_or_v == 'h' else HEIGHT
    for i in range(lines):
        if h_or_v == 'v':
            x1, x2 = xx1 * i, xx2 * i
            y1, y2 = yy1, yy2
        else:
            y1, y2 = yy1 * i, yy2 * i
            x1, x2 = xx1, xx2
        pygame.draw.line(screen, BLACK, (x1, y1), (x2, y2), lw)


# stuff for displaying cards
def get_angles(num, angle):
    l1 = []
    if angle == 0:
        for i in range(num):
            l1.append(0)
        #print(l1)
        return l1
    if num % 2 == 1:
        start = (num - 1) * angle // 2
        l1 = [-start + angle * interval for interval in range(num)]
    else:
        for interval in range(num + 1):
            start = (num - 2) * angle // 2 + angle
            cur_num = -start + angle * interval
            if cur_num != 0:
                l1.append(cur_num)
    l1.reverse()
    #print(l1)
    return l1


def decode_cards(card):
    # r'cards/2_of_hearts.png'
    high_cards = {'J': 'jack', 'Q': 'queen', 'K': 'king', 'A': 'ace', 'BR': 'Back_Red', 'BG': 'Back_Grey',
                  'BB': 'Back_Blue'}
    final_str = r'cards/'
    # print(card)
    if card[0].isdigit():
        final_str += f'{card[0]}_of_{card[1].lower()}.png'
    elif card[0][0] != 'B':
        if card[0] == 'A':
            final_str += f'{high_cards[card[0]]}_of_{card[1].lower()}.png'
        else:
            final_str += f'{high_cards[card[0]]}_of_{card[1].lower()}{get_data(SETTINGS, 3, 0)}.png'
    else:
        final_str += f'{high_cards[card[0]]}_{card[1]}.png'
    return final_str


def display_cards(x_start, x_end, y_start, y_end, angle, offset, cards):
    # pygame.draw.circle(screen, RED, (x_start,y_start), 5)
    # pygame.draw.circle(screen, RED, (x_end,y_end), 5)

    num_cards = len(cards)
    angle_list = get_angles(num_cards, angle)
    middle_width = x_end - x_start
    middle_height = y_end - y_start
    card_height = middle_height / 1.15
    card_width = card_height // 1.38
    x = x_start
    y = y_start

    if num_cards % 2 == 0:
        x_add = ((middle_width - (
                card_width * (num_cards // (num_cards - num_cards // 3) if num_cards - 2 > 0 else 1))) // (
                         num_cards - 1))
    elif num_cards == 1:
        x_add, x = 0, (middle_width // 2) - (card_width // 2) + x_start
    else:
        x_add = ((middle_width - (card_width * 1)) // (num_cards - 1))

    if offset > 0:
        y_add = offset
    else:
        y_add = 0

    for i in range(num_cards):
        load_text = decode_cards(cards[i])
        next_card = pygame.image.load(load_text)
        next_card = pygame.transform.scale(next_card, (card_width, card_height))
        next_card = pygame.transform.rotate(next_card, angle_list[i])
        screen.blit(next_card, (x, y))
        x += x_add if i < num_cards / 2 else x_add // 1.25
        y += y_add
    # pygame.draw.circle(screen, RED, (x,y_start), 5)


# buttons displaying
def center_text(text, font_height):
    new_new_list = []
    high_len = 0
    # QWERTYUIOPASDFGHJKLXCVBNM
    for x in range(len(text)):
        high_len = 0
        new_list = []
        for i in range(len(text[x])):
            current_len = len(text[x][i])
            # long_let = ['Q', 'W', 'M', '', '', '', '', '', '', '']
            # current_len += 1 if
            if current_len > high_len:
                high_len = current_len
        for i in range(len(text[x])):
            new_text = text[x][i]
            while len(new_text) < high_len + 3:
                new_text = '  ' + new_text if len(new_text) < high_len else ' ' + new_text
            new_list.append(new_text)
        new_new_list.append(new_list)
    box_length = (MARGIN // 2) * (high_len) * 1.25
    # print(box_length)
    return new_new_list, box_length


def display_supper_buttons(x_start, x_end, y_start, y_end, button_width, button_height, font, font_size, all_text,
                           text_color, box_color1, box_color2, mouse, check, on):
    cols = len(all_text)
    middle_width = x_end - x_start
    middle_height = y_end - y_start
    mh_nonbttons = middle_height - (button_height * cols)
    y_add = mh_nonbttons / (cols - 1) if (cols - 1) != 0 else 0
    y = y_start
    for current_row in range(cols):
        x = x_start
        mw_nonbttons = middle_width - (button_width * len(all_text[current_row]))
        x_add = mw_nonbttons / (len(all_text[current_row]) - 1) if (len(all_text[current_row]) - 1) != 0 else 0
        for current_button in range(len(all_text[current_row])):
            if None != all_text[current_row][current_button] != '':
                thefont = pygame.font.SysFont(font, font_size)
                text = thefont.render(all_text[current_row][current_button], True, text_color)
                if x <= mouse[0] <= x + button_width and y <= mouse[1] <= y + button_height and on[current_row][
                    current_button] != 0:
                    pygame.draw.rect(screen, box_color2, [x, y, button_width, button_height])
                    if check is True:
                        return current_row, current_button
                # elif on[current_row][current_button] != 0:
                else:
                    pygame.draw.rect(screen, box_color1, [x, y, button_width, button_height])

                text_rect = text.get_rect(center=((x + button_width - x) // 2 + x, (y + button_height - y) // 2 + y))
                screen.blit(text, text_rect)
            x += x_add + button_width
        y += y_add + button_height
    return None


# mislainious functions

def make_window(bg_color, text):
    screen = pygame.display.set_mode((DISPLAY))
    pygame.display.set_caption(text)
    screen.fill(bg_color)
    return screen


def draw_rect_alpha(surface, color, rect):
    shape_surf = pygame.Surface(pygame.Rect(rect).size, pygame.SRCALPHA)
    pygame.draw.rect(shape_surf, color, shape_surf.get_rect())
    surface.blit(shape_surf, rect)


def blit_text_alpha(surface, text_surf, cords):
    text_surf.set_alpha(160)
    surface.blit(text_surf, cords)


# game windo functions

def display_dealer(running, dealer, mouse, check):
    fill_col = (163, 189, 162)
    surface_width = WIDTH // 10 * 2.25
    surface_height = HEIGHT // 10 * 7
    if not Player.show_dealer:
        pygame.draw.rect(screen, fill_col, [0, 0, surface_width, surface_height])
    else:
        pygame.draw.rect(screen, GREEN, [0, 0, surface_width, surface_height])

    button_height = MARGIN
    button_width = MARGIN * 2.5
    button = display_supper_buttons(MARGIN // 2, surface_width - MARGIN // 2, MARGIN // 2, MARGIN // 2 + button_height,
                                    button_width, button_height, 'Corbel', MARGIN, [['QUIT', 'HELP']], WHITE, BLACK,
                                    GRAY, mouse, check, [[1, 1]])

    smallfont = pygame.font.SysFont('freesansbold.ttf', HEIGHT // 8 * 3 - HEIGHT // 8 * 2)
    text = smallfont.render('DEALER', True, BLACK)
    x_start, x_width = MARGIN * 2, MARGIN * 3
    y_start, y_height = surface_height - MARGIN * 3, MARGIN * 2.5

    if running and not Player.show_dealer and dealer is not None:
        # print([[get_data(SETTINGS, 0, 0), str(get_data(SETTINGS, 1, 0))], dealer["cards"]])
        display_cards(MARGIN, surface_width - MARGIN, MARGIN * 2, surface_height - MARGIN * 3, 4, 0,
                      [[get_data(SETTINGS, 0, 0), str(get_data(SETTINGS, 1, 0))], dealer["cards"][1]])
        text_rect = text.get_rect(center=(
            ((x_start + x_width) - x_start) + x_start // 2 // 2, (y_start + y_height - y_height) + y_height // 2))
        screen.blit(text, text_rect)

    if Player.show_dealer:
        text_rect = text.get_rect(
            center=((surface_width) // 2, (surface_height - MARGIN - button_height) // 2 - MARGIN // 2 + button_height))
        screen.blit(text, text_rect)
        text = smallfont.render(str(dealer["total"]), True, BLACK)
        text_rect = text.get_rect(center=((surface_width) // 2, (
                surface_height - MARGIN - button_height) // 2 - MARGIN + button_height + HEIGHT // 8 * 3 - HEIGHT // 8 * 2))
        screen.blit(text, text_rect)
    return button


def display_card_option(running, card, mouse, check, options, cur_hand, card_list):
    fill_col = (163, 189, 162)
    x_start = WIDTH // 10 * 8
    surface_width = WIDTH - WIDTH // 10 * 8
    surface_height = HEIGHT // 10 * 7
    card_height = surface_width - (MARGIN // 2) * 2
    card_width = card_height // 1.38
    x = x_start + MARGIN // 2
    y = MARGIN // 2

    if not Player.show_dealer:
        pygame.draw.rect(screen, fill_col, [x_start, 0, surface_width, surface_height])
    else:
        pygame.draw.rect(screen, GREEN, [x_start, 0, surface_width, surface_height])
    load_text = decode_cards(card)
    next_card = pygame.image.load(load_text)
    next_card = pygame.transform.scale(next_card, (card_width, card_height))
    next_card = pygame.transform.rotate(next_card, 90)
    screen.blit(next_card, (x, y))
    if running or Player.show_dealer:
        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN * 2)
        text = smallfont.render(str(len(card_list)), True, BLACK)
        text_rect = text.get_rect(
            center=((x + card_height + MARGIN // 2) // 2 + x_start // 2, (y + card_width + MARGIN // 2) // 2))
        screen.blit(text, text_rect)

    if running is False and not Player.show_dealer:
        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN * 2)
        deal_col = WHITE if WIDTH - surface_width + MARGIN // 2 <= mouse[0] <= WIDTH - MARGIN // 2 and MARGIN // 2 <= \
                            mouse[1] <= MARGIN // 2 + card_width else BLACK
        if len(Player.playing_list) > 0:
            text = smallfont.render(("DEAL"), True, deal_col)
            text_rect = text.get_rect(
                center=((x + card_height + MARGIN // 2) // 2 + x_start // 2, (y + card_width + MARGIN // 2) // 2))
            screen.blit(text, text_rect)
            if WIDTH - surface_width + MARGIN // 2 <= mouse[0] <= WIDTH - MARGIN // 2 and MARGIN // 2 <= mouse[
                1] <= MARGIN // 2 + card_width and check:
                return 0, "deal"
        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN)
        text = smallfont.render(f'Min Bet: {get_data(SETTINGS, 0, 1)}', True, BLACK)
        text_rect = text.get_rect(
            center=((surface_width) // 2 + x_start * 2 // 2, (surface_height) // 2 + y - MARGIN * 1.5))
        screen.blit(text, text_rect)
    # print(Player.continue_game)
    if running and Player.continue_game and not Player.show_dealer and options != None:
        on = []
        all_text = []
        # print(options)
        for i in range(len(options)):
            all_text.append([options[i]])
            on.append([1])
        font, font_size = 'Corbel', MARGIN

        button_height, button_width = MARGIN, MARGIN * 4
        x_s, x_e = x_start + ((surface_width - button_width) // 2), x_start + (
                (button_width - surface_width) // 2) + button_width
        total_height = button_height * len(all_text)
        true_ys, true_ye = y + card_width, surface_height
        buffer = ((true_ye - true_ys) - total_height) // 2
        y_s, y_e = true_ys + buffer, true_ye - buffer
        button = display_supper_buttons(x_s, x_e, y_s, y_e, button_width, button_height, font, font_size, all_text,
                                        WHITE, BLACK, GRAY, mouse, check, on)
        return button, "option"
    # print(Player.continue_game, Player.show_dealer, Player.graded)

    size_list = {"stand": MARGIN * 3, "bust": MARGIN * 3, "surrender": MARGIN * 1.3, "double": MARGIN * 2,
                 "21": MARGIN * 1.25, "bj": MARGIN * 1.6}
    str_list = {"stand": "Stand", "bust": "Bust", "surrender": "Surrendered", "double": "Doubled", "21": "You Got 21",
                "bj": "BlackJack"}

    the_text = "why god why!!!"
    text = None
    button = None
    on = [[1]]
    all_text = [['CONTINUE']]
    font, font_size = 'Corbel', MARGIN
    y_s = y + card_width + MARGIN
    button_height, button_width = MARGIN, MARGIN * 5
    x_s, x_e = x_start + ((surface_width - button_width) // 2), x_start + (
            (button_width - surface_width) // 2) + button_width
    y_e = y_s + button_height * len(all_text)

    if (running or Player.show_dealer or Player.graded) and not Player.continue_game:
        button = display_supper_buttons(x_s, x_e, y_s, y_e, button_width, button_height, font, font_size, all_text,
                                        WHITE, BLACK, GRAY, mouse, check, on)
    if not Player.show_dealer and cur_hand != None and running and cur_hand["status"] != "in_play":
        smallfont = pygame.font.SysFont('freesansbold.ttf', round(size_list[cur_hand["status"]]))
        the_text = str_list[cur_hand["status"]]
        text = smallfont.render(the_text, True, BLACK)
    if not Player.graded and Player.show_dealer:
        smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN * 1.5))
        chv, fv = cur_hand["total"], get_data(SETTINGS, 0, 3)
        str_list = {"17": f"Got {fv}", "bust": "Busted", "above": "Above 17", "bj": "BlackJack", "in_play": "Hitting",
                    "Got 21": "Got 21"}
        # print(cur_hand["status"])
        the_text = str_list[cur_hand["status"]]
        text = smallfont.render(the_text, True, BLACK)
    if Player.graded and Player.show_dealer:
        smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN * 1.5))
        the_text = "Finished"
        text = smallfont.render(the_text, True, BLACK)
    # print(the_text)
    if text != None:
        text_rect = text.get_rect(
            center=((x_start + surface_width - x_start) // 2 + x_start, (surface_height - y_e - MARGIN) // 2 + y_e))
        screen.blit(text, text_rect)
    if button != None:
        return button, "continue"

    # if False is True:
    # for i in range(2000):
    # smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN)
    # the_text = "SHUFFLING"
    # the_text += "." * random.randint(0, 3)
    # text = smallfont.render(the_text, True, BLACK)
    # text_rect = text.get_rect(center=((x + card_height + MARGIN // 2) // 2 + x_start // 2, (y + card_width + MARGIN // 2) // 2))
    # screen.blit(text, text_rect)
    # screen.blit(next_card, (x, y))
    return None, None


def bet_chip(chip, chip_width, chip_height, x, y, cur_player, what, d_chips):
    if what == "show":
        final_str = r'chips/chip_'
        final_str += f'{d_chips[chip]}_top_large.png'
        load_text = final_str
        next_card = pygame.image.load(load_text)
        next_card = pygame.transform.scale(next_card, (chip_width, chip_height))
        next_card = pygame.transform.rotate(next_card, 90)
        screen.blit(next_card, (x, y))


def super_chip(chip_list, chip_width, chip_height, x_start, x_end, y, mouse, check, cur_player, top, d_chips, chip_num):
    box_width = x_end - x_start
    full_len = chip_width * len(chip_list) + MARGIN // 2 * (len(chip_list))
    buffer = (box_width - full_len) // 2
    x = x_start + buffer + MARGIN // 1.5
    for i in range(len(chip_list)):
        final_str = r'chips/chip_'
        final_str += f'{d_chips[chip_list[i]]}_top_large.png'
        load_text = final_str
        next_card = pygame.image.load(load_text)
        next_card = pygame.transform.scale(next_card, (chip_width, chip_height))
        next_card = pygame.transform.rotate(next_card, 90)
        screen.blit(next_card, (x, y))

        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN // 3)
        text = smallfont.render(str(chip_num[chip_list[i]]), True, BLACK)
        text_rect = text.get_rect(center=((chip_width + x - x) // 2 + x, (chip_height + y - y) // 2 + y))
        screen.blit(text, text_rect)

        if x <= mouse[0] <= x + chip_width and y <= mouse[1] <= y + chip_height and check:
            cur_player["balance"] -= chip_num[chip_list[i]]
            cur_player["bet"] += chip_num[chip_list[i]]
            cur_player["pev_chip"] = chip_list[i]
            # bet_chip(chip_list[i], MARGIN, MARGIN, x_start+buffer+MARGIN//2, top+MARGIN//2, cur_player, "show")
        x += MARGIN * 1.25

    for i in range(Player.total_players):
        buffer = (box_width - MARGIN * 2) // 4
        if cur_player["bet"] >= get_data(SETTINGS, 0, 1):
            x1 = x_start + buffer
            x2 = top + MARGIN // 2
            big_chip = cur_player["pev_chip"]
            bet_chip(big_chip, MARGIN * 2, MARGIN * 2, x1, x2, cur_player, "show", d_chips)
            smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN / 1.5))
            text = smallfont.render(str(cur_player["bet"]), True, BLACK)
            text_rect = text.get_rect(center=((MARGIN * 2 + x1 - x1) // 2 + x1, (MARGIN * 2 + x2 - x2) // 2 + x2))
            screen.blit(text, text_rect)

        x1 = x_start + buffer * 3
        x2 = top + MARGIN
        button_width, button_height = MARGIN * 2, MARGIN // 1.5
        if x1 <= mouse[0] <= x1 + button_width and x2 <= mouse[1] <= x2 + button_height:
            pygame.draw.rect(screen, TRANS_GRAY, [x1, x2, button_width, button_height])
        else:
            pygame.draw.rect(screen, BLACK, [x1, x2, button_width, button_height])
        if x1 <= mouse[0] <= x1 + button_width and x2 <= mouse[1] <= x2 + button_height and check:
            cur_player["balance"] += cur_player["bet"]
            cur_player["bet"] = 0
        x3 = x2 - MARGIN // 1.5
        smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN / 1.5))
        text = smallfont.render('CLEAR', True, WHITE)
        text_rect = text.get_rect(center=((MARGIN * 2 + x1 - x1) // 2 + x1, (MARGIN * 2 + x3 - x3) // 2 + x3))
        screen.blit(text, text_rect)
        color = SHOW_GREEN if x1 <= mouse[0] <= x1 + button_width and x2 + button_height <= mouse[
            1] <= x2 + button_height * 2 and cur_player["balance"] > 0 else BLACK
        smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN / 1.5))
        text = smallfont.render("$" + str(cur_player["balance"]), True, color)
        text_rect = text.get_rect(center=((MARGIN * 2 + x1 - x1) // 2 + x1, (MARGIN * 2 + x2 - x2) // 2 + x2))
        screen.blit(text, text_rect)
        if x1 <= mouse[0] <= x1 + button_width and x2 + button_height <= mouse[1] <= x2 + button_height * 2:
            if check and cur_player["balance"] > 0:
                og_bet = cur_player["bet"]
                if cur_player["bet"] == 0:
                    cur_player["bet"] = cur_player["balance"] // 2
                    cur_player["balance"] -= cur_player["bet"]
                    cur_player["pev_chip"] = chip_list[0]
                    check = False
                elif og_bet == cur_player["bet"]:
                    cur_player["bet"] += cur_player["balance"]
                    cur_player["balance"] = 0
                    check = False
                    cur_player["pev_chip"] = chip_list[0]


def get_chips(cur_player):
    num_list = [1, 5, 25, 100, 500, 1000, 5000]
    chips_to_value = {1: "WC", 5: "RC", 25: "GC", 100: "BC", 500: "PC", 1000: "YC", 5000: "OC"}
    final_list = []
    for i in range(len(num_list)):
        if num_list[i] <= cur_player["balance"]:
            final_list.append(chips_to_value[num_list[i]])
    # print(final_list)
    end_dict = {value: key for key, value in chips_to_value.items()}
    return final_list[-4:], end_dict


def display_chips(player_list, top, x, x_add, t, mouse, check):
    d_chips = {"WC": "white", "RC": "red", "GC": "green", "BC": "black", "PC": "purple", "B2C": "lightblue",
               "YC": "yellow", "OC": "biege"}
    current_player = player_list[f"user_{t}"]
    click_chips, value_chips = get_chips(current_player)
    x_start, x_end, y = x, x + x_add, HEIGHT - MARGIN * 1.5
    super_chip(click_chips, MARGIN, MARGIN, x_start, x_end, y, mouse, check, current_player, top, d_chips, value_chips)


def who_playing(player_list):
    Player.playing_list = []
    for i in range(Player.total_players):
        t = Player.player_list[i]
        current_player = player_list[f"user_{t}"]
        if current_player["bet"] >= get_data(SETTINGS, 0, 1):
            Player.playing_list.append(Player.player_list[i])
        current_player["pev_bet"] = current_player["bet"]


def display_cards_in_boxes(player_list, top, x, x_add, t, mouse, check):
    current_player = player_list[f"user_{t}"]
    dealer = player_list["user_0"]
    dealer_hand = dealer["hand-0"]
    # bust, got 21, blackjack, finished
    std = {"bust": "Busted", "bj": "Blackjack", "stand": "Finished", "double": "Finished", "surrender": "Finished",
           "21": "Got 21"}
    if t in Player.playing_list and current_player["total_num_hands"] > 0:
        x_start = x + MARGIN * 1.5
        x_end = x + (x_add - MARGIN * 0.5)
        y_start = top + MARGIN // 4
        y_add = ((HEIGHT) - y_start) // current_player["total_num_hands"]  # + MARGIN//4
        y = y_start
        # print(current_player["total_num_hands"], t)
        for k in range(current_player["total_num_hands"]):
            cur_hand = current_player[f"hand-{k}"]
            card_height = (y + y_add - y) / 1.15
            card_width = card_height // 1.38
            # print(cur_hand["cards"])
            # print(card_width, cur_hand["card_num"])
            total_card_width = card_width * cur_hand["card_num"] - MARGIN // 4
            buffer = ((x_end - x_start) - total_card_width) // 2
            xs = x_start + buffer if total_card_width < (x_end - x_start) else x_start
            xe = x_end - buffer if total_card_width < (x_end - x_start) else x_end

            if cur_hand["status"] == "at_hand":
                draw_rect_alpha(screen, CURRENT_GREEN, (x, y - MARGIN // 4, x_add, y_add + MARGIN // 4))
                # draw a green rect behind the cards or future get a cool image

            # print(cur_hand["card_num"])
            smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN))
            text = smallfont.render(str(cur_hand["total"]), True, BLACK)
            text_rect = text.get_rect(center=((xs - x_start) // 2 + x_start, (y + y_add - y) // 2 + y))
            screen.blit(text, (xs - MARGIN, text_rect[1]))

            display_cards(xs, xe, y, y + y_add, 2, 0, cur_hand["cards"])

            # display what the cards are doing
            # if Player.t != e:
            if cur_hand["status"] != "at_hand" and not Player.show_dealer:
                smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN // current_player["total_num_hands"]))
                # text_rect = text.get_rect(center=((xs+xe - xs) // 2 + xs//2-MARGIN//current_player["total_num_hands"]*.5, (y + y_add - y) // 2 + y))
                the_xs = xs - MARGIN // (current_player["total_num_hands"]) if current_player[
                                                                                   "total_num_hands"] < 3 else xs
                text_rect = text.get_rect(center=((xe - xs) // 2 + the_xs, (y + y_add - y) // 2 + y))

                draw_rect_alpha(screen, TRANS_GRAY, (x, y, x_add, y_add))
                wait_str = "Waiting"
                wait_str += "." * random.randint(0, 3)
                the_text = std[cur_hand["status"]] if cur_hand["status"] != "in_play" else wait_str
                text = smallfont.render(the_text, True, BLACK)
                screen.blit(text, text_rect)
            if Player.graded or Player.show_dealer:
                smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN // current_player["total_num_hands"]))
                the_xs = xs - MARGIN // (current_player["total_num_hands"]) if current_player[
                                                                                   "total_num_hands"] < 3 else xs
                text_rect = text.get_rect(center=((xe - xs) // 2 + the_xs, (y + y_add - y) // 2 + y))

                wait_str = "Waiting"
                wait_str += "." * random.randint(0, 3)
                # other_str = judge_hand(cur_hand, dealer_hand)
                # other_str = cur_hand["outcome"]
                the_text = wait_str  # if not Player.graded else other_str
                if not Player.graded:
                    draw_rect_alpha(screen, TRANS_GRAY, (x, y, x_add, y_add))
                    text = smallfont.render(the_text, True, BLACK)
                    screen.blit(text, text_rect)
                else:
                    # writes transparent winlostpush text
                    # print(x, top, x_add, y_add)

                    # print(text_rect)
                    the_text = judge_hand(cur_hand, dealer_hand, current_player)
                    color_dict = {"LOST": SHOW_RED, "WON": SHOW_GREEN, "PUSH": SHOW_YELLOW}
                    font_size = round(y_add + MARGIN) if Player.total_players < 4 or current_player[
                        "total_num_hands"] > 1 else round(MARGIN * 3.25)
                    smallfont = pygame.font.SysFont('freesansbold.ttf', font_size)
                    text = smallfont.render(the_text, True, color_dict[the_text])
                    text_rect = text.get_rect(center=((x_add) // 2 + x, (y_add) // 2 + y))
                    blit_text_alpha(screen, text, text_rect)
            y += y_add


def display_players_game(player_list, running, mouse, check):
    tan = (176, 157, 106)
    tan1 = (179, 165, 129)
    fill_col = (163, 189, 162)
    pla_bx_col = (129, 145, 128)
    text_color = (77, 73, 94)
    top = HEIGHT // 10 * 7
    top2 = HEIGHT // 10 * 7 + MARGIN
    side_start = WIDTH // 10 * 2.25
    side_end = WIDTH // 10 * 8
    pygame.draw.rect(screen, fill_col, [0, top, WIDTH, HEIGHT])

    top2 = HEIGHT // 10 * 7 + MARGIN
    x_add = WIDTH // Player.total_players
    x = 0
    for i in range(Player.total_players):
        t = Player.player_list[i]
        # displays the players name over the boxes
        pygame.draw.rect(screen, pla_bx_col, [x, top2, x + x_add, HEIGHT])
        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN)
        name = player_list[f"user_{t}"]["name"] + f" {t}" if player_list[f"user_{t}"]["name"] == "PLAYER" else \
            player_list[f"user_{t}"]["name"]
        text = smallfont.render(name, True, text_color)
        text_rect = text.get_rect(center=(((x + x_add - x) + x * 2) // 2, ((top2 - top) // 2) + top))
        screen.blit(text, text_rect)

        # displays and holds the logic for betting
        if not running and not Player.show_dealer:
            display_chips(player_list, top2, x, x_add, t, mouse, check)

        # displays the cards while the game is running
        if running or Player.show_dealer:
            display_cards_in_boxes(player_list, top2, x, x_add, t, mouse, check)
            display_current_cards(side_start, side_end, top, player_list, pla_bx_col, text_color)
        x += x_add
    # finds who has bets down
    if not running and not Player.show_dealer:
        who_playing(player_list)

    # displays the cards for the small boxes
    # if running:
    # display_cards_in_boxes(player_list, top2, )

    # draws seprations lines
    pygame.draw.line(screen, BLACK, (0, top + MARGIN), (WIDTH, top + MARGIN), MARGIN // 6)
    pygame.draw.line(screen, BLACK, (0, top), (WIDTH, top), MARGIN // 6)
    for i in range(Player.total_players - 1):
        x_start = (WIDTH // (Player.total_players)) * (i + 1)
        pygame.draw.line(screen, BLACK, (x_start, top), (x_start, HEIGHT), MARGIN // 6)
    # if running and 2+2 == 1:
    # for i in range(Player.total_players):
    # x_start = (WIDTH // (Player.total_players)) * (i)
    # pygame.draw.line(screen, BLACK, (x_start + MARGIN, top2), (x_start + MARGIN, HEIGHT), MARGIN // 6)


def display_current_cards(x_start, x_end, y_end, player_list, pla_bx_col, text_color):
    fill_col = (163, 189, 162)
    y_start1 = 0
    y_start2 = y_start1 + MARGIN
    t = Player.playing_list[Player.t] if not Player.show_dealer else 0
    # print(t, player_list)
    pygame.draw.rect(screen, GREEN, [x_start, y_start1, x_end - x_start, y_end - y_start1])
    current_player = player_list[f"user_{t}"]
    if current_player["num_hands"] > 0:
        cur_hand = current_player["hand-" + str(current_player["hand"][-1])]
        if not Player.show_dealer:
            # displays the players name over the boxes
            pygame.draw.rect(screen, pla_bx_col, [x_start, y_start1, x_end - x_start, y_start2 - y_start1])
            smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN)
            name = current_player["name"] + f" {t}" if current_player["name"] == "PLAYER" else current_player["name"]
            hand = "        Hand " + str(current_player["hand"][-1] + 1)
            text = smallfont.render(name + hand, True, text_color)
            text_rect = text.get_rect(center=((x_end - x_start) // 2 + x_start, (y_start2 - y_start1) // 2))
            screen.blit(text, text_rect)
        else:
            pygame.draw.rect(screen, GREEN, [x_start, y_start1, x_end - x_start, y_start2 - y_start1])

        xs, xe = x_start + MARGIN, x_end - MARGIN
        ys, ye = y_start2 + MARGIN, y_end - MARGIN
        card_height = (ye - ys) / 1.15
        card_width = card_height // 1.38
        total_card_width = card_width * cur_hand["card_num"] - MARGIN
        buffer = ((xe - xs) - total_card_width) // 2
        xs = xs + buffer if total_card_width < (xe - xs) else xs
        xe = xe - buffer if total_card_width < (xe - xs) else xe

        display_cards(xs, xe, ys, ye, 4, 0, cur_hand["cards"])

        if not Player.show_dealer:
            smallfont = pygame.font.SysFont('freesansbold.ttf', HEIGHT // 8 * 3 - HEIGHT // 8 * 2)
            text = smallfont.render(str(cur_hand["total"]), True, BLACK)
            text_rect = text.get_rect(center=((x_end - x_start) // 2 + x_start, (y_end - ye) // 2 + ye - MARGIN // 2))
            screen.blit(text, text_rect)


def display_image(x, y, image_width, image_height, angle, load_image):
    image = pygame.image.load(load_image)
    image = pygame.transform.scale(image, (image_width, image_height))
    image = pygame.transform.rotate(image, angle)
    screen.blit(image, (x, y))


def check_quit():
    txt_col = WHITE
    bx_col1 = BLACK
    bx_col2 = (94, 93, 93)
    trans1 = TRANS_GRAY
    draw_rect_alpha(screen, trans1, (0, 0, WIDTH, HEIGHT))
    while True:
        x_start, y_start = WIDTH // 10 * 4, HEIGHT // 10 * 4
        x_end, y_end = WIDTH // 10 * 6 - x_start, HEIGHT // 10 * 6 - y_start
        pygame.draw.rect(screen, bx_col2, [x_start, y_start, x_end, y_end])
        pygame.draw.rect(screen, bx_col2, [x_start, y_start, x_end, y_end], 2, 3)

        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN // 2)
        text = smallfont.render('Are you sure all bets will be lost!', True, BLACK)
        text_rect = text.get_rect(
            center=((x_end - x_start) // 2 + x_start * 1.5, (y_start + MARGIN - y_start) // 2 + y_start))
        screen.blit(text, text_rect)

        xs, ys = x_start + MARGIN // 2, y_start + MARGIN * 1.25
        iw, ih = (x_end // 2) - MARGIN // 1.25, (y_end - MARGIN) - MARGIN // 1.25

        display_image(xs, ys, iw, ih, 0, r'other/green_check.png')
        display_image(xs + iw + MARGIN // 2, ys, iw, ih, 0, r'other/red_x.png')

        for ev in pygame.event.get():
            mouse = pygame.mouse.get_pos()
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            display_image(xs, ys, iw, ih, 0, r'other/green_check.png')
            if xs <= mouse[0] <= xs + iw and ys <= mouse[1] <= ys + ih and ev.type == pygame.MOUSEBUTTONDOWN:
                return True
            display_image(xs + iw + MARGIN // 2, ys, iw, ih, 0, r'other/red_x.png')
            if xs + iw + MARGIN <= mouse[0] <= xs + iw + MARGIN + iw and ys <= mouse[
                1] <= ys + ih and ev.type == pygame.MOUSEBUTTONDOWN:
                return False
            if (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end + x_start or mouse[1] < y_start or mouse[
                1] > y_end + y_start)):
                return False

        pygame.display.update()


def display_dealer_final(bg_color, player_list, card_list, running):
    dealer = player_list["user_0"]
    dealer_hand = dealer["hand-0"]
    fpsClock = pygame.time.Clock()
    fps = 30
    fps_count = 0
    seconds_count = 0
    wait_time = 2
    Player.continue_game = True
    clean_options = False
    while True:
        fps_count += 1
        if fps_count >= fps / 2:
            seconds_count += 1
            fps_count = 0
        if seconds_count >= wait_time or wait_time == 0:
            if wait_time != 0 and get_data(SETTINGS, 4, 3) == 'on':
                if dealer_hand["total"] < get_data(SETTINGS, 0, 3) or (
                        get_data(SETTINGS, 3, 3) == 'on' and dealer_hand["num_aces"] > 0) and dealer_hand[
                    "total"] != 21:
                    get_value(add_card(dealer_hand, card_list), dealer_hand, card_list)
                    check_hand(dealer_hand, "dealer", dealer)
                    seconds_count = 0
                    clean_options = True
            else:
                while dealer_hand["total"] < get_data(SETTINGS, 0, 3) or (
                        get_data(SETTINGS, 3, 3) == 'on' and dealer_hand["num_aces"] > 0) and dealer_hand[
                    "total"] != 21:
                    get_value(add_card(dealer_hand, card_list), dealer_hand, card_list)
                    check_hand(dealer_hand, "dealer", dealer)
                    seconds_count = 0
                    clean_options = True
        for ev in pygame.event.get():
            mouse = pygame.mouse.get_pos()
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            display_players_game(player_list, running, mouse, ev.type == pygame.MOUSEBUTTONDOWN)

            button = display_dealer(running, dealer_hand, mouse, ev.type == pygame.MOUSEBUTTONDOWN)
            if button != None:
                if button == (0, 0):
                    if Player.t < len(Player.playing_list) and running or Player.show_dealer:
                        if check_quit() is False:
                            screen.fill(bg_color)
                            display_players_game(player_list, running, mouse, ev.type == pygame.MOUSEBUTTONDOWN)
                            break
                        end_game(player_list, running, False)
                        return True
                if button == (0, 1):
                    print("Help is not available")
            if (ev.type == pygame.MOUSEBUTTONDOWN and button is None) or get_data(SETTINGS, 4, 3) == 'off':
                wait_time = 0

            option_button, op_or_deal = display_card_option(running,
                                                            [get_data(SETTINGS, 0, 0), str(get_data(SETTINGS, 1, 0))],
                                                            mouse, ev.type == pygame.MOUSEBUTTONDOWN, [], dealer_hand,
                                                            card_list)  # flagged [] to none
            if ev.type == pygame.MOUSEBUTTONDOWN and Player.continue_game is False and button is None:
                op_or_deal = "continue"
                option_button = (0, 0)
            if op_or_deal == "continue" and option_button != None and Player.continue_game is False:
                Player.continue_game = True
                clean_options = True
                if Player.graded is False:
                    Player.graded = True
                    Player.continue_game = True
                else:
                    # score_screen(player_list)
                    return False
        pev_stat = dealer_hand["status"]
        check_hand(dealer_hand, 'dealer', dealer)
        if dealer_hand["status"] != pev_stat:
            clean_options = True
        if clean_options:
            na, na = display_card_option(running, [get_data(SETTINGS, 0, 0), str(get_data(SETTINGS, 1, 0))], (0, 0),
                                         None, [], dealer_hand, card_list)  # flagged
            na = display_dealer(running, dealer_hand, (0, 0), False)
            clean_options = False
        if Player.continue_game and not Player.graded:
            if (dealer_hand["total"] >= get_data(SETTINGS, 0, 3) and (get_data(SETTINGS, 3, 3) == 'off')) or \
                    dealer_hand["total"] == 21:
                Player.continue_game = False
                clean_options = True
            elif get_data(SETTINGS, 3, 3) == 'on' and dealer_hand["num_aces"] == 0:
                Player.continue_game = False
                clean_options = True
        if Player.graded and Player.continue_game is True:
            Player.continue_game = False
            # print("who won")

        display_players_game(player_list, running, (0, 0), False)
        pygame.display.update()
        fpsClock.tick(fps)


def display_player_scores(player_list, current_number, end_number, at_hand, done, start_balance, continue_list,
                          difrence_list):
    x_start = WIDTH // 10 * 1
    x_end = WIDTH // 10 * 9
    surface_width = x_end - x_start
    y_start = HEIGHT // 10 * 2
    y_end = HEIGHT // 10 * 8
    surface_height = y_end - y_start
    gray = (179, 179, 179)
    pygame.draw.rect(screen, gray, [x_start, y_start, surface_width, surface_height])

    pygame.draw.line(screen, BLACK, (x_start, y_start + MARGIN), (x_end, y_start + MARGIN), MARGIN // 6)
    for i in range(len(at_hand) - 1):
        x_start1 = (surface_width // (len(at_hand))) * (i + 1) + x_start
        pygame.draw.line(screen, BLACK, (x_start1, y_start + MARGIN), (x_start1, y_end), MARGIN // 6)

    x = x_start
    y = y_start + MARGIN
    x_add = surface_width // len(at_hand)
    new_height = surface_height - MARGIN
    # print(x_add, x, surface_width, x_start, x_end)
    # x -= x_add * (len(at_hand)-1)
    for player in range(len(at_hand)):

        current_player = player_list[f"user_{Player.playing_list[player]}"]
        # hand_num = at_hand[player]
        # cur_hand = current_player[f"hand-{hand_num}"]

        colors = [RED, SHOW_GREEN, BLACK]
        smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN)

        t = Player.player_list[player]
        name = current_player["name"] + f" {t}" if current_player["name"] == "PLAYER" else current_player["name"]
        text = smallfont.render(name, True, BLACK)
        text_rect = text.get_rect(center=((x_add) // 2 + x, (MARGIN) // 2 + y_start))
        screen.blit(text, text_rect)

        if not Time.start_showing and sum(done) == 0:
            text = smallfont.render("BALANCE", True, BLACK)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 3.5) // 2 + y))
            screen.blit(text, text_rect)

            text = smallfont.render(str(start_balance[player]), True, BLACK)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 3.5) // 2 + y + MARGIN))
            screen.blit(text, text_rect)

        if Time.start_showing and (done[player] != 1 or continue_list[player] is False):
            # displays the hand and +-
            hand_num = at_hand[player] if continue_list[player] is False and done[player] != 1 else at_hand[player] + 1
            hand_text = f"HAND {hand_num}"
            # difrence = abs(end_number[player] - current_player["balance"])
            difrence = difrence_list[player]
            # pls_min_num = f"+- {difrence}" if current_player["balance"] == end_number[player] else f"+ {difrence}" if end_number[player] > current_player["balance"] else f"- {difrence}"
            pls_min_num = f"+- {difrence}" if difrence == 0 else f"+ {difrence}" if difrence > 0 else f"- {abs(difrence)}"
            num_color = BLACK if difrence == 0 else SHOW_GREEN if difrence > 0 else RED
            # num_color =  BLACK if current_player["balance"] == end_number[player] else SHOW_GREEN if end_number[player] > current_player["balance"] else RED

            text = smallfont.render(hand_text, True, BLACK)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 1) // 2 + y))
            screen.blit(text, text_rect)

            text = smallfont.render(pls_min_num, True, num_color)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 1) // 2 + y + MARGIN))
            screen.blit(text, text_rect)

            # displays the balance and cur balance
            text = smallfont.render("BALANCE", True, BLACK)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 3.5) // 2 + y))
            screen.blit(text, text_rect)

            text = smallfont.render(str(current_number[player]), True, BLACK)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 3.5) // 2 + y + MARGIN))
            screen.blit(text, text_rect)
        if (done[player] == 1):
            num_color = BLACK if current_player["balance"] == start_balance[player] else SHOW_GREEN if start_balance[
                                                                                                           player] < \
                                                                                                       current_player[
                                                                                                           "balance"] else RED

            text = smallfont.render("BALANCE", True, BLACK)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 3.5) // 2 + y))
            screen.blit(text, text_rect)

            text = smallfont.render(str(current_player["balance"]), True, num_color)
            text_rect = text.get_rect(center=((x_add) // 2 + x, (new_height // 4 * 3.5) // 2 + y + MARGIN))
            screen.blit(text, text_rect)

        x += x_add
    # smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN)
    # text = smallfont.render(str(cur_num), True, BLACK)
    # text_rect = text.get_rect(center=((WIDTH) // 2 + MARGIN*2 * num, (HEIGHT) // 2))
    # screen.blit(text, text_rect)


def quick_add(player_list, current_number, end_number, at_hand, done, start_balance, continue_list, difrence_list):
    for player in range(len(Player.playing_list)):
        current_player = player_list[f"user_{Player.playing_list[player]}"]
        hand_num = at_hand[player]
        cur_hand = current_player[f"hand-{hand_num}"]
        for i in range(current_player["total_num_hands"]):
            current_number[player] = current_player["balance"]
            end_number[player] = current_player["balance"] + cur_hand["bet"]
            current_number = end_number
            current_player["balance"] = current_number[player]
            end_number[player] = 0
            if at_hand[player] + 1 < current_player["total_num_hands"]:
                at_hand[player] += 1
            else:
                break
        done[player] = 1
    return done

#name| nickname,passowrd,email,balance,total_games,+-,$won,$lost,putin,wins,losses,pushes,bj
def update_data(key, current_player, start_balance):

    add_data(ACCOUNTS, '', key["balance"], get_line(ACCOUNTS, current_player["name"]))
    add_data(ACCOUNTS, str(current_player["balance"]), key["balance"], get_line(ACCOUNTS, current_player["name"]))

    print(start_balance, current_player["balance"], "balances")
    if start_balance < current_player["balance"]:
        #add_data(ACCOUNTS, '', key["$won"], get_line(ACCOUNTS, current_player["name"]))
        add_data(ACCOUNTS, current_player["balance"] - start_balance, key["$won"], get_line(ACCOUNTS, current_player["name"]))
    elif start_balance > current_player["balance"]:
        #add_data(ACCOUNTS, '', key["$lost"], get_line(ACCOUNTS, current_player["name"]))
        add_data(ACCOUNTS,start_balance - current_player["balance"], key["$lost"], get_line(ACCOUNTS, current_player["name"]))

    won = get_data(ACCOUNTS, key["$won"], get_line(ACCOUNTS, current_player["name"]))
    lost = get_data(ACCOUNTS, key["$lost"], get_line(ACCOUNTS, current_player["name"]))
    print(won, lost)
    there = get_data(ACCOUNTS, key["+-"], get_line(ACCOUNTS, current_player["name"]))
    end = (won-lost)
    add_data(ACCOUNTS, '', key["+-"], get_line(ACCOUNTS, current_player["name"]))
    add_data(ACCOUNTS, end, key["+-"], get_line(ACCOUNTS, current_player["name"]))


    #add_data(ACCOUNTS, int(won-lost), key["+-"], get_line(ACCOUNTS, current_player["name"]))

def score_screen(player_list):
    on = [[1, 0], [0, 1]]
    txt_col = WHITE
    bx_col1 = BLACK
    bx_col2 = GRAY
    trans1 = TRANS_GRAY
    x_s, x_e, y_s, y_e = MARGIN, WIDTH - MARGIN, MARGIN, HEIGHT - MARGIN
    button_width, button_height = MARGIN * 6, MARGIN * 2
    font, font_size, all_text = 'Corbel', MARGIN, [['QUIT', ''], ['', 'PLAY AGAIN']]
    fpsClock = pygame.time.Clock()
    fps = 30
    fps_count = 0
    seconds_count = 0
    wait_time = 2
    count_time = 2
    screen.fill(GREEN)
    tf_continue = []
    current_number = []
    finished = 0
    end_number = []
    at_hand = []
    frame_add = []
    number_add = []
    frame_list = []
    done = []
    period_wait = []
    fps_count_list = []
    wait = []
    continue_list = []
    start_balance = []
    difrence_list = []
    fps_boost = False
    Time.start_showing = False
    added_data = False
    Time.done = False
    for player in range(len(Player.playing_list)):
        tf_continue.append(True)
        current_number.append(0)
        end_number.append(0)
        at_hand.append(0)
        frame_add.append(0)
        number_add.append(0)
        frame_list.append(0)
        done.append(0)
        period_wait.append(0)
        fps_count_list.append(0)
        wait.append(0)
        continue_list.append(True)
        start_balance.append(0)
        difrence_list.append(0)
    for player in range(len(Player.playing_list)):
        start_balance[player] = player_list[f"user_{Player.playing_list[player]}"]["balance"]
        player_list[f"user_{Player.playing_list[player]}"]["start_balance"] = start_balance[player]
    na = display_supper_buttons(x_s, x_e, y_s, y_e, button_width, button_height, font, font_size, all_text, txt_col,
                                bx_col1, bx_col2, (0, 0), False, on)

    while True:

        # counter
        fps_count += 1

        # print(Player.playing_list, Time.skip)
        if Time.start_showing:
            for player in range(len(Player.playing_list)):
                current_player = player_list[f"user_{Player.playing_list[player]}"]
                hand_num = at_hand[player]
                cur_hand = current_player[f"hand-{hand_num}"]
                if tf_continue[player] and done[player] != 1 and continue_list[player]:
                    current_number[player] = current_player["balance"]
                    end_number[player] = current_player["balance"] + cur_hand["bet"]

                    if current_player["total_num_hands"] > at_hand[player]:
                        tf_continue[player] = False
                        frame_period = fps * count_time
                        # change_value = abs(cur_hand["bet"])
                        # print(cur_hand["bet"], 'show bet')
                        change_value = cur_hand["bet"]
                        difrence_list[player] = change_value
                        # print(frame_period, change_value)
                        if not fps_boost:
                            if count_time > 0 and abs(change_value) > 0:
                                if frame_period < abs(change_value):

                                    # number_add[player] = math.ceil(change_value / frame_period)
                                    number_add[player] = math.ceil(change_value / frame_period)

                                else:
                                    frame_add[player] = math.ceil(frame_period / abs(change_value))
                            else:
                                number_add[player] = change_value
                        else:
                            current_number[player] = end_number[player]
                # time_list.append(cur_hand["bet"])
        elif not Time.done:
            if fps_count >= fps / 2:
                seconds_count += .5
                fps_count = 0
            if seconds_count >= wait_time:
                seconds_count = 0
                Time.start_showing = True
                fps_count = 0

        for player in range(len(period_wait)):
            if not fps_boost:
                if period_wait[player] > 0:
                    if fps_count_list[player] > fps / 2:
                        period_wait[player] -= .5
                    else:
                        fps_count_list[player] += 1
                    if period_wait[player] == 0:
                        continue_list[player] = True
                else:
                    fps_count_list[player] = 0
            else:
                period_wait[player] = 0
                continue_list[player] = True
        for ev in pygame.event.get():
            mouse = pygame.mouse.get_pos()
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            check = ev.type == pygame.MOUSEBUTTONDOWN

            button = display_supper_buttons(x_s, x_e, y_s, y_e, button_width, button_height, font, font_size, all_text,
                                            txt_col, bx_col1, bx_col2, mouse, check, on)
            if button != None:
                # print(button)
                if button == (0, 0):
                    if not Time.done:
                        done = quick_add(player_list, current_number, end_number, at_hand, done, start_balance,
                                         continue_list, difrence_list)
                        key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5,
                               "$lost": 6, "putin": 7,
                               "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
                        for player in range(len(Player.playing_list)):
                            current_player = player_list[f"user_{Player.playing_list[player]}"]
                            update_data(key, current_player, start_balance[player])
                        added_data = True
                    return False
                if button == (1, 1):
                    if not Time.done:
                        done = quick_add(player_list, current_number, end_number, at_hand, done, start_balance,
                                         continue_list, difrence_list)
                        key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5,
                               "$lost": 6, "putin": 7,
                               "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
                        for player in range(len(Player.playing_list)):
                            current_player = player_list[f"user_{Player.playing_list[player]}"]
                            update_data(key, current_player, start_balance[player])

                        added_data = True
                    return True
            if ((check and button is None) or get_data(SETTINGS, 4, 3) == 'off') and not Time.done:
                wait_time = 2
                count_time = 2
                fps = 30
                fps_boost = True
                done = quick_add(player_list, current_number, end_number, at_hand, done, start_balance, continue_list,
                                 difrence_list)
                Time.done = True
                Time.start_showing = False
                # ight make a for that runs thrught all curent things and make them equal to end number
                # print("fpsbost")
            # pygame.draw.rect(screen, GREEN, [x_start, y_start, x_end, y_end])

        if Time.start_showing:

            for player in range(len(Player.playing_list)):
                reset = False
                current_player = player_list[f"user_{Player.playing_list[player]}"]
                hand_num = at_hand[player]
                if tf_continue[player] != True and done[player] == 0 and continue_list[player]:
                    if frame_add[player] != 0:
                        if current_number[player] != end_number[player]:
                            if frame_list[player] >= frame_add[player]:
                                current_number[player] += 1 if end_number[player] > current_number[player] else -1
                                frame_list[player] = 0
                            else:
                                frame_list[player] += 1
                        else:
                            reset = True
                    elif number_add[player] != 0:
                        # print(current_number[player], end_number[player])
                        if current_number[player] != end_number[player]:
                            if end_number[player] < current_number[player]:
                                if current_number[player] + number_add[player] < end_number[player]:
                                    change_value = abs(end_number[player] - current_number[player])
                                    frame_period = fps * count_time
                                    number_add[player] = math.ceil(change_value / frame_period)
                                    print(number_add[player])
                                current_number[player] += number_add[player] if 1 != number_add[player] else -1

                                # current_number[player] += number_add[player] if current_number[player] + number_add[player] > end_number[player] else -1
                            else:
                                if current_number[player] + number_add[player] > end_number[player]:
                                    change_value = abs(end_number[player] - current_number[player])
                                    frame_period = fps * count_time
                                    number_add[player] = math.ceil(change_value / frame_period)
                                current_number[player] += number_add[player] if -1 != number_add[player] else 1

                                # current_number[player] += number_add[player] if current_number[player] + number_add[player] < end_number[player] else 1
                        else:
                            reset = True
                    else:
                        reset = True
                if reset:
                    period_wait[player] = wait_time * 2
                    continue_list[player] = False
                    if at_hand[player] + 1 < current_player["total_num_hands"]:
                        tf_continue[player] = True
                    else:
                        tf_continue[player] = False
                        done[player] = 1

                    # current_number[player] = 0
                    end_number[player] = 0
                    frame_list[player] = 0
                    at_hand[player] += 1 if at_hand[player] + 1 < current_player["total_num_hands"] else 0
                    frame_add[player] = 0
                    number_add[player] = 0
                    current_player["balance"] = current_number[player]

            # print(len(current_number), current_number, end_number, frame_add, number_add)
            # pygame.draw.rect(screen, GREEN, [0, 0, WIDTH, HEIGHT])
            # for player in range(len(current_number)):
            # if current_number[player] != 0:
            # print(current_number[player], "cur num")
            # display_player_scores(current_number[player], player)

        # print(current_number, end_number, done, number_add)

        display_player_scores(player_list, current_number, end_number, at_hand, done, start_balance, continue_list,
                              difrence_list)

        if sum(done) == len(Player.playing_list) and not Time.done:
            for player in range(len(Player.playing_list)):
                finished += 1 if continue_list[player] is True else 0
            if finished == len(Player.playing_list):
                Time.done = True
                Time.start_showing = False
            else:
                finished = 0
                # print("just show balance")
        if Time.done and not added_data:
            key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5, "$lost": 6,"putin": 7,
                   "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
            for player in range(len(Player.playing_list)):
                current_player = player_list[f"user_{Player.playing_list[player]}"]
                update_data(key, current_player, start_balance[player])
            added_data = True
        pygame.display.update()
        fpsClock.tick(fps)


def end_game(player_list, running, finished):
    current_player = player_list[f"user_{0}"]
    for i in range(4):
        current_player[f"hand-{i}"] = Hands()
    current_player["num_hands"] = 1
    current_player["num_busts"] = 0
    current_player["hand"] = [0]
    current_player["bet"] = 0
    current_player["total_cards"] = []
    current_player["total_num_hands"] = 1
    key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5, "$lost": 6, "putin": 7,
            "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
    if not finished:
        list_of_all = [player_list[f"user_{Player.player_list[player]}"] for player in range(len(Player.player_list))]
        list_of_playing = [player_list[f"user_{Player.playing_list[player]}"] for player in
                           range(len(Player.playing_list))]
        # print(Player.player_list)
        # print(list_of_playing, "list_of_playing")
        for checking in range(len(list_of_all)):
            # print(list_of_all, list_of_playing)
            if list_of_all[checking] not in list_of_playing or (not running and not Player.show_dealer):
                list_of_all[checking]["balance"] += list_of_all[checking]["bet"]
            else:
                for i in range(list_of_all[checking]["total_num_hands"]):
                    cur_hand = list_of_all[checking][f"hand-{i}"]
                    list_of_all[checking]["balance"] -= cur_hand["bet"]
                    update_data(key, list_of_all[checking], list_of_all[checking]["balance"]+cur_hand["bet"])
        for player in range(len(Player.player_list)):
            current_player = player_list[f"user_{Player.player_list[player]}"]
            current_player["bet"] = 0
    for player in range(len(Player.playing_list)):
        current_player = player_list[f"user_{Player.playing_list[player]}"]
        for i in range(4):
            current_player[f"hand-{i}"] = Hands()
        current_player["num_hands"] = 1
        current_player["num_busts"] = 0
        current_player["hand"] = [0]
        current_player["bet"] = 0
        current_player["total_cards"] = []
        current_player["total_num_hands"] = 1
    Player.playing_list = []
    Player.t = 0
    Player.show_dealer = False
    Player.graded = False
    Player.total_busts = 0
    Player.continue_game = True


# main game function
def game(bg_color, num_players, player_list, name_list):
    screen = make_window(bg_color, 'BLACKJACK')
    del_add_player("add_deal", player_list, name_list, "dealer")
    running = False
    card_list = make_52()
    # print(card_list)
    dealer_hand = None
    cur_hand = None
    next_hand = None
    current_player = None
    button_list = None
    new_choice = False
    option_button = None
    end_hand = False
    clean_options = False
    Player.next_game = True
    while Player.next_game:
        for player in range(len(player_list) - 1):
            current_player = player_list[f"user_{Player.player_list[player]}"]
            if get_data(SETTINGS, 1, 3) == 'on':
                if current_player["pev_bet"] <= current_player["balance"]:
                    current_player["bet"] = current_player["pev_bet"]
                    current_player["balance"] -= current_player["pev_bet"]
                else:
                    current_player["bet"] = current_player["balance"]
                    current_player["balance"] = 0

        while True:
            if running and Player.continue_game:

                x = 100 / (get_data(SETTINGS, 2, 0) * 52)
                if len(card_list) * x <= 20:
                    card_list = reshuffle(card_list)
                    na = display_dealer(running, dealer_hand, (0, 0), False)
                    na, na = display_card_option(running, [get_data(SETTINGS, 0, 0), str(get_data(SETTINGS, 1, 0))],
                                                 (0, 0), None, button_list, cur_hand, card_list)
                current_player = player_list[f"user_{Player.playing_list[Player.t]}"]

                # print(current_player["num_hands"])
                if current_player["num_hands"] == 0:
                    Player.t += 1

                    if Player.t >= len(Player.playing_list):
                        # running = False
                        # print("end")
                        Player.show_dealer = True
                        running = False
                        screen.fill(bg_color)
                        player_quit = display_dealer_final(bg_color, player_list, card_list, running)
                        # end_screen()
                        if not player_quit:
                            continue_game = score_screen(player_list)
                            end_game(player_list, running, True)
                            if continue_game:
                                Player.next_game = True
                                screen.fill(bg_color)
                            else:
                                Player.next_game = False
                        else:
                            end_game(player_list, running, False)
                            Player.next_game = False
                        Player.show_dealer = False
                        break
                    else:
                        # print(f"user_{Player.playing_list[Player.t]}")
                        current_player = player_list[f"user_{Player.playing_list[Player.t]}"]
                        continue

                cur_hand = current_player["hand-" + str(current_player["hand"][-1])]
                cur_hand["status"] = "at_hand"
                next_hand = current_player["hand-" + str(current_player["total_num_hands"])] if current_player[
                                                                                                    "total_num_hands"] < 4 else None
            dealer = player_list["user_0"]
            dealer_hand = dealer["hand-0"]
            button_list = find_options(cur_hand, dealer_hand, current_player) if running else None

            if clean_options is True and button_list != None:
                na, na = display_card_option(running, [get_data(SETTINGS, 0, 0), str(get_data(SETTINGS, 1, 0))], (0, 0),
                                             None, button_list, cur_hand, card_list)
                clean_options = False

                # continue
            # idea is to make a check choice thing if the button != None or sum and if it does then it does ^ if its not hit or split or if not true
            # add another varabile that is togable that is continue whenre every thig happend if continue == true and if hand ends then continue == false and only the button that if continue us presed then it will make contunue true
            # also add a hand status somewhere saying in play, bust, 21, blackjack, stand, double so the use knows

            for ev in pygame.event.get():
                mouse = pygame.mouse.get_pos()

                if ev.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                button = display_dealer(running, dealer_hand, mouse, ev.type == pygame.MOUSEBUTTONDOWN)
                if button != None:
                    if button == (0, 0):
                        if Player.t < len(Player.playing_list) and running:
                            if check_quit() is False:
                                screen.fill(bg_color)
                                display_players_game(player_list, running, mouse, ev.type == pygame.MOUSEBUTTONDOWN)
                                break
                        end_game(player_list, running, False)
                        Player.next_game = False
                        return False
                    if button == (0, 1):
                        print("Help is not available")

                display_players_game(player_list, running, mouse, ev.type == pygame.MOUSEBUTTONDOWN)

                option_button, op_or_deal = display_card_option(running, [get_data(SETTINGS, 0, 0),
                                                                          str(get_data(SETTINGS, 1, 0))], mouse,
                                                                ev.type == pygame.MOUSEBUTTONDOWN, button_list,
                                                                cur_hand, card_list)
                if option_button != None:
                    clean_options = True
                if op_or_deal == "deal":
                    deal_cards(player_list, card_list)
                    running = True
                    break
                elif op_or_deal == "option" and option_button != None and Player.continue_game:
                    # now it goes up and checks there
                    # print(option_button, "button")
                    outcome = get_outcome(option_button, button_list, cur_hand, next_hand, card_list, current_player)
                    # print(outcome, "outcome")
                    if outcome is False:
                        new_choice = True
                        # print("false out")
                    break
                elif op_or_deal == "continue" and option_button != None and Player.continue_game is False:
                    Player.continue_game = True
                    # print("continue")

                    break
                if Player.continue_game is False and ev.type == pygame.MOUSEBUTTONDOWN and button == None:
                    # print(button)
                    Player.continue_game = True
            if running is True and current_player != None and new_choice is False and end_hand is False:
                cur_hand = current_player["hand-" + str(current_player["hand"][-1])]
            if running and cur_hand != None and end_hand is False:
                display_players_game(player_list, running, None, None)
                if not check_hand(cur_hand, "player", current_player) or new_choice is True:
                    Player.continue_game = False
                    new_choice = False
                    end_hand = True
                    clean_options = True
            if clean_options is True and button_list != None:
                na, na = display_card_option(running, [get_data(SETTINGS, 0, 0), str(get_data(SETTINGS, 1, 0))], (0, 0),
                                             None, button_list, cur_hand, card_list)
                if Player.continue_game is False:
                    clean_options = False
            if end_hand is True and Player.continue_game is True:
                end_hand = False
                finish_hand(current_player)

            # devide_screen(10, 'h', 5)
            # devide_screen(10, 'v', 5)

            # display_cards(50, 550, 50, 500, 6, 4, 0, [['A', 'Hearts'], ['Q', 'Hearts'], ['8', 'Spades'], ['5', 'Diamonds'],['A', 'Hearts'], ['8', 'Spades'], ['5', 'Diamonds'],['A', 'Hearts'], ['8', 'Spades'], ['5', 'Diamonds'],['A', 'Hearts'], ['8', 'Spades'],['A', 'Hearts'], ['8', 'Spades'], ['5', 'Diamonds'],['A', 'Hearts'], ['8', 'Spades']])
            pygame.display.update()
    return True


# windows for menu
def display_lock(x_start, y_start):
    image = r'other/black_lock.png'
    load_chip = pygame.image.load(image)
    load_chip = pygame.transform.scale(load_chip, (MARGIN * 1.5, MARGIN * 1.5))
    load_chip = pygame.transform.rotate(load_chip, 0)
    screen.blit(load_chip, (x_start, y_start - MARGIN // 4))


def admin_locked_screen():
    text_color = WHITE
    box_color1 = BLACK
    box_color2 = GRAY
    box_color3 = (94, 93, 93)
    trans1 = TRANS_GRAY
    button_height, button_width = MARGIN, MARGIN * 2
    on = [[1, 1]]
    button_text = [['BACK', 'ENTER']]
    font, font_size1, font_size2 = "Corbel", round(MARGIN // 2), MARGIN

    x_start, y_start = WIDTH // 10 * 4, HEIGHT // 10 * 4
    # x_end, y_end = WIDTH // 10 * 6 - x_start, HEIGHT // 10 * 6 - y_start
    x_end, y_end = WIDTH // 10 * 6, HEIGHT // 10 * 6
    surface_width, surface_height = x_end - x_start, y_end - y_start

    xs, ys = x_start + MARGIN // 2, y_start + MARGIN // 4
    xe, ye = x_end - MARGIN // 2, y_start + MARGIN * 2

    pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])
    na = display_supper_buttons(xs, xe, ys + MARGIN * 2.25, ye, button_width, button_height, font, font_size1,
                                button_text, text_color, box_color1, box_color2, (0, 0), False, on)
    add_data(SETTINGS, '2_5', 0, 4)
    while True:

        # box_color3 = (94, 93, 93)
        # pygame.draw.rect(screen, box_color3, [x_start, y_start, x_end, y_end], 2, 3)

        smallfont = pygame.font.SysFont('Corbel', MARGIN // 2)
        text = smallfont.render('ENTER ADMIN PASSWORD', True, BLACK)
        text_rect = text.get_rect(center=((surface_width) // 2 + x_start, (surface_height) // 2 + y_start))
        screen.blit(text, (text_rect[0], y_start + MARGIN // 4))

        clicked, locked, current, check, mouse, ev = 0, False, '2_5', False, (0, 0), None
        clicked += text_box(x_start + MARGIN // 4, y_start + MARGIN, surface_width - MARGIN // 2, MARGIN, font,
                            font_size2, mouse, ev, check, current, 0, 'pass', locked, SETTINGS)

        for ev in pygame.event.get():
            # clicked += text_box(x_start + MARGIN // 4, y_start + MARGIN, surface_width - MARGIN // 2, MARGIN, font,font_size2, (0,0), None, False, '2_5', None, 'str', False)

            mouse = pygame.mouse.get_pos()
            check = ev.type == pygame.MOUSEBUTTONDOWN
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            button1 = display_supper_buttons(xs, xe, ys + MARGIN * 2.25, ye, button_width, button_height, font,
                                             font_size1, button_text, text_color, box_color1, box_color2, mouse, check,
                                             on)
            if button1 != None or ev.type == pygame.KEYDOWN:
                if button1 == (0, 0) or (ev.type == pygame.KEYDOWN and ev.key == pygame.K_ESCAPE):
                    add_data(SETTINGS, '', 2, 5)
                    add_data(SETTINGS, '', 1, 5)
                    return False
                if button1 == (0, 1) or (ev.type == pygame.KEYDOWN and ev.key == pygame.K_RETURN):
                    if get_data(SETTINGS, 0, 5) == get_data(SETTINGS, 2, 5):
                        add_data(SETTINGS, '', 2, 5)
                        add_data(SETTINGS, '', 1, 5)
                        return True
                    else:
                        add_data(SETTINGS, '', 2, 5)
                        add_data(SETTINGS, '', 1, 5)
                        return False

            clicked, locked, current = 0, False, '2_5'
            clicked += text_box(x_start + MARGIN // 4, y_start + MARGIN, surface_width - MARGIN // 2, MARGIN, font,
                                font_size2, mouse, ev, check, current, 0, 'pass', locked, SETTINGS)
            if clicked == 0:
                add_data(SETTINGS, '0_0', 0, 4)

            if (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end + x_start or mouse[1] < y_start or mouse[
                1] > y_end + y_start)):
                add_data(SETTINGS, '', 2, 5)
                add_data(SETTINGS, '', 1, 5)
                return False

        pygame.display.update()


def text_box(x_start, y_start, button_width, button_height, font, font_size, mouse, ev, check, current, the_max,
             the_type, locked, file):
    box_color = BLACK
    box_color2 = SHOW_GREEN
    clicked = 0
    text_color = WHITE  # mabye add it to check if you hover over it
    trans_1 = TRANS_GRAY
    num1 = int(current[:current.index('_')])
    num2 = int(current[current.index('_') + 1:])
    # print(num1, num2)
    # print(locked, "1")
    if not locked:
        if x_start <= mouse[0] <= x_start + button_width and y_start <= mouse[1] <= y_start + button_height and check:
            add_data(SETTINGS, f'{num1}_{num2}', 0, 4)
            clicked += 1
    elif current != get_data(SETTINGS, 0, 4):
        if x_start <= mouse[0] <= x_start + button_width and y_start <= mouse[1] <= y_start + button_height and check:
            if admin_locked_screen():
                add_data(SETTINGS, f'{num1}_{num2}', 0, 4)
                clicked += 1
                locked = False
    else:
        locked = False

    pygame.draw.rect(screen, box_color, [x_start, y_start, button_width, button_height])

    # print(locked, "2")
    if not check:
        clicked += 1
    # elif check:
    # add_data(SETTINGS, '0_0', 0, 4)

    data = str(get_data(file, num1, num2))
    if the_max == None:
        print((get_data(SETTINGS, 0, 4)))
        print(data, current)

    # length = len(get_data(SETTINGS, 2, 5)) - 1
    # the_data = data if the_type != 'pass' else f"{'*' * length}{get_data(SETTINGS, 2, 5)[-1]}" if len(get_data(SETTINGS, 2, 5)) > 0 else data
    the_data = data if the_type != 'pass' else get_data(SETTINGS, 1, 5)
    smallfont = pygame.font.SysFont(font, font_size)
    text = smallfont.render(str(the_data), True, text_color)
    text_rect = text.get_rect(center=((button_width) // 2 + x_start, (font_size) // 2 + y_start))
    cords = text_rect if the_type == 'int' else (x_start, text_rect[1])
    screen.blit(text, cords)

    if ev is not None and ev.type != pygame.MOUSEMOTION:
        if current == get_data(SETTINGS, 0, 4) and not locked:
            pygame.draw.rect(screen, box_color, [x_start, y_start, button_width, button_height])
            pygame.draw.rect(screen, text_color, pygame.Rect(x_start, y_start, button_width, button_height), 2)
            if ev.type == pygame.KEYDOWN:
                if ev.key == pygame.K_BACKSPACE:
                    if len(data) > 0:
                        add_data(file, '', num1, num2)
                        add_data(file, data[:-1], num1, num2)
                        if the_type == 'pass':
                            add_data(SETTINGS, get_data(SETTINGS, 1, 5)[:-1], 1, 5)
                elif ev.key == pygame.K_RETURN:
                    add_data(SETTINGS, '0_0', 0, 4)
                else:
                    if the_type == 'int':
                        if ev.unicode.isdigit():
                            if type(the_max) != str and int(f'{data}{ev.unicode}') <= the_max:
                                data += str(ev.unicode)
                            elif type(the_max) != str and int(f'{data}{ev.unicode}') > the_max:
                                data = str(the_max)
                            add_data(file, '', num1, num2)
                            add_data(file, data, num1, num2)
                    else:
                        data += ev.unicode
                        add_data(file, data, num1, num2)

                        if the_type == 'pass':
                            length = len(str(get_data(SETTINGS, 2, 5))) - 1
                            add_data(SETTINGS,  f"{'*' * length}{str(get_data(SETTINGS, 2, 5))[-1]}", 1, 5)
                    # has the triogen horse layer over this so it look like stars and ...

    if locked and 1 + 1 == 3:
        # pygame.draw.rect(screen, BLACK, [x_start, y_start, button_width, button_height])
        smallfont = pygame.font.SysFont('freesansbold.ttf', font_size)
        text = smallfont.render('Locked', True, WHITE)
        text_rect = text.get_rect(center=((button_width) // 2 + x_start, (font_size) // 2 + y_start))
        screen.blit(text, text_rect)
        # draw_rect_alpha(screen, TRANS_GRAY, [x_start, y_start, button_width, button_height])
    if locked:
        display_lock(x_start + button_width, y_start)

    if current == get_data(SETTINGS, 0, 4):
        pygame.draw.rect(screen, text_color, pygame.Rect(x_start, y_start, button_width, button_height), 2)
    if current != get_data(SETTINGS, 0, 4):
        draw_rect_alpha(screen, trans_1, [x_start, y_start, button_width, button_height])
    return clicked


def on_off_switch(x_start, y_start, button_width, button_height, left_side, right_side, font, font_size, on, mouse,
                  check, locked):
    box_color = BLACK
    text_color = WHITE  # mabye add it to check if you hover over it
    trans_1 = TRANS_GRAY
    pygame.draw.rect(screen, box_color, [x_start, y_start, button_width, button_height])

    smallfont = pygame.font.SysFont(font, font_size)
    text = smallfont.render(left_side, True, text_color)
    text_rect = text.get_rect(center=((button_width // 2) // 2 + x_start, (font_size) // 2 + y_start))
    # if not locked:
    screen.blit(text, text_rect)
    # else:
    # blit_text_alpha(screen, text, text_rect)
    text = smallfont.render(right_side, True, text_color)
    text_rect = text.get_rect(
        center=((button_width // 2) // 2 + x_start + button_width // 2, (font_size) // 2 + y_start))
    # if not locked:
    screen.blit(text, text_rect)
    # else:
    # blit_text_alpha(screen,text,text_rect)

    if on == left_side.lower():
        # if not locked:
        draw_rect_alpha(screen, trans_1, [x_start + button_width // 2, y_start, button_width // 2, button_height])
        pygame.draw.rect(screen, text_color, pygame.Rect(x_start, y_start, button_width // 2, button_height), 2)
    elif on == right_side.lower():
        # if not locked:
        draw_rect_alpha(screen, trans_1, [x_start, y_start, button_width // 2, button_height])
        pygame.draw.rect(screen, text_color,
                         pygame.Rect(x_start + button_width // 2, y_start, button_width // 2, button_height), 2)

    # if locked:
    # draw_rect_alpha(screen, trans_1, [x_start, y_start, button_width, button_height])

    if x_start <= mouse[0] <= x_start + button_width // 2 and y_start <= mouse[1] <= y_start + button_height and check:
        if locked and on != left_side.lower():
            if admin_locked_screen():
                on = left_side.lower()
        else:
            on = left_side.lower()
    elif x_start + button_width // 2 <= mouse[0] <= x_start + button_width // 2 + button_width // 2 and y_start <= \
            mouse[1] <= y_start + button_height and check:
        if locked and on != right_side.lower():
            if admin_locked_screen():
                on = right_side.lower()
        else:
            on = right_side.lower()

    if locked and 1 + 1 == 3:
        smallfont = pygame.font.SysFont('freesansbold.ttf', font_size)
        text = smallfont.render('Locked', True, WHITE)
        text_rect = text.get_rect(center=((button_width) // 2 + x_start, (button_height) // 2 + y_start))
        blit_text_alpha(screen, text, text_rect)
        # screen.blit(text, text_rect)

    if locked:
        display_lock(x_start + button_width, y_start)

    return on
    # pygame.draw.line(screen, BLACK, (x_start1, y_start + MARGIN), (x_start1, y_end), MARGIN // 6)


def display_settings_toggles(x_start, y_start, x_end, y_end, num_buttons, mouse, check, ev):
    clicked = 0
    button_height, button_width = MARGIN, MARGIN * 4
    left_side, right_side = 'ON', 'OFF'
    font, font_size = "Corbel", round(MARGIN)
    y_add = (y_end - y_start - (button_height * num_buttons)) // num_buttons + button_height - MARGIN // 18
    # print(y_start, y_end, num_buttons, button_height)
    # print(y_add)
    y = y_start + (y_add - button_height) - MARGIN // 6
    current_list = ['2_0', '1_1', '0_1', '0_3']
    max_list = [8, 100000, get_data(SETTINGS, 1, 1), 210]
    locked = False
    # print(max_list)
    for i in range(4):
        locked = False
        current = current_list[i]
        the_max = max_list[i]
        if current == '1_1' and len(Player.player_list) > 0 or current == '0_3':
            locked = True
        if get_data(SETTINGS, 5, 3) == 'on':
            locked = True
        clicked += text_box(x_start, y, button_width, button_height, font, font_size, mouse, ev, check, current,
                            the_max, 'int', locked, SETTINGS)

        if type(get_data(SETTINGS, 1, 1)) != str != type(get_data(SETTINGS, 0, 1)) and (get_data(SETTINGS, 0, 1)) > (
                get_data(SETTINGS, 1, 1)):
            add_data(SETTINGS, '', 0, 1)
            add_data(SETTINGS, str(max_list[2]), 0, 1)
        if len(str(get_data(SETTINGS, 1, 1))) == 0:
            add_data(SETTINGS, '', 0, 1)
        if clicked == 0:
            add_data(SETTINGS, '0_0', 0, 4)
        y += y_add

    for i in range(1, 6):
        on = get_data(SETTINGS, i, 3)
        if get_data(SETTINGS, 5, 3) == 'on' or i == 5:
            locked1 = True
        else:
            locked1 = False
        # transparent font over the on off if locked and you have to click the one that is not on to get the adimin popup and then it changes
        on = on_off_switch(x_start, y, button_width, button_height, left_side, right_side, font, font_size, on, mouse,
                           check, locked1)
        add_data(SETTINGS, on, i, 3)
        y += y_add
        y_add -= MARGIN // 35


def left_side_settings(x_start, y_start, x_end, y_end, surface_width, surface_height, mouse, check, ev):
    text_color = BLACK
    box_color1 = GRAY
    box_color2 = GRAY
    trans1 = TRANS_GRAY
    on = [[0], [0], [0], [0], [0], [0], [0]]
    text = [['Decks'], ['Start Balance'], ['Min Bet'], ['Dealer'], ['Auto Bet'], ['Insurance'], ['Soft 17'],
            ['Cutscenes'], ['Game Lock']]
    button_height, button_width = MARGIN * 2, MARGIN * 5
    x_s, x_e = x_start + MARGIN, x_start + MARGIN + button_width
    y_s, y_e = y_start + MARGIN, y_end - MARGIN
    font, font_size = 'Corbel', button_height // 2
    button1 = display_supper_buttons(x_s, x_e, y_s, y_e, button_width, button_height, font, font_size, text,
                                     text_color, box_color1, box_color2, (0, 0), False, on)
    display_settings_toggles(x_s + button_width + MARGIN // 2, y_s, x_e + button_width, y_e + MARGIN // 4, len(text),
                             mouse, check, ev)

    return button1


def check_data():
    current_list = ['2_0', '1_1', '0_1', '0_3']
    max_list = [8, 1000000, get_data(SETTINGS, 1, 1), 21]
    average_list = [2, 500, 5, 17]
    add_data(SETTINGS, '0_0', 0, 4)
    for i in range(4):
        current = current_list[i]
        the_max = max_list[i]
        num1 = int(current[:current.index('_')])
        num2 = int(current[current.index('_') + 1:])
        data = get_data(SETTINGS, num1, num2)
        # print(data)
        if type(data) != str:
            if data == 0:
                add_data(SETTINGS, str(0), num1, num2)
                add_data(SETTINGS, str(average_list[i]), num1, num2)
        else:
            add_data(SETTINGS, str(0), num1, num2)
            add_data(SETTINGS, str(average_list[i]), num1, num2)

    if type(get_data(SETTINGS, 1, 1)) != str != type(get_data(SETTINGS, 0, 1)) and (get_data(SETTINGS, 0, 1)) > (
            get_data(SETTINGS, 1, 1)):
        add_data(SETTINGS, str(0), 0, 1)
        add_data(SETTINGS, str(max_list[2]), 0, 1)


def setting_window(trans1, gray):
    txt_col = WHITE
    bx_col1 = BLACK
    bx_col2 = GRAY
    trans1 = TRANS_GRAY
    on = [[1]]
    draw_rect_alpha(screen, trans1, (0, 0, WIDTH, HEIGHT))
    change = False
    x_start, x_end = WIDTH // 10 * 1, WIDTH // 10 * 9
    y_start, y_end = HEIGHT // 10 * 1, HEIGHT // 10 * 9
    text = [['SAVE']]
    button_height, button_width = MARGIN, MARGIN * 5
    bx_start, bx_end = MARGIN, WIDTH - MARGIN
    by_start, by_end = MARGIN // 2, MARGIN // 2 + button_height
    font, font_size = 'Corbel', button_height
    # had evil help button here

    surface_width, surface_height = x_end - x_start, y_end - y_start
    while True:

        for ev in pygame.event.get():
            change = True
            mouse = pygame.mouse.get_pos()
            check = ev.type == pygame.MOUSEBUTTONDOWN
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            # button = menu_buttons_top(txt_col, bx_col1, bx_col2, ev.type == pygame.MOUSEBUTTONDOWN, mouse,top_buttons_onoff)
            button = display_supper_buttons(bx_start, bx_end, by_start, by_end, button_width, button_height, font,
                                            font_size, text, txt_col, bx_col1, bx_col2, mouse, check, on)
            if button == (0, 0) or (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                check_data()
                return True
            left_side_settings(x_start, y_start, x_end, y_end, surface_width, surface_height, mouse, check, ev)

        if change == True:
            pygame.draw.rect(screen, GRAY, [x_start, y_start, surface_width, surface_height])
            pygame.draw.rect(screen, BLACK, pygame.Rect(x_start, y_start, surface_width, surface_height), 5)
            left_side_settings(x_start, y_start, x_end, y_end, surface_width, surface_height, (0, 0), False, None)
            change = False
        pygame.display.update()


def menu_buttons_top(text_color, box_color1, box_color2, check, mouse, on):
    text = [['SETTINGS', 'QUIT']]
    button_height, button_width = MARGIN, MARGIN * 5
    x_start, x_end = MARGIN, WIDTH - MARGIN
    y_start, y_end = MARGIN // 2, MARGIN // 2 + button_height
    font, font_size = 'Corbel', button_height
    # had evil help button here
    button = display_supper_buttons(x_start, x_end, y_start, y_end, button_width, button_height, font, font_size, text,
                                    text_color, box_color1, box_color2, mouse, check, on)
    # if button != None:
    # flip[button[0]][button[1]] = 1 if flip[button[0]][button[1]] == 0 else 0

    return button  # , flip


def display_bj_text(text_color):
    smallfont = pygame.font.SysFont('freesansbold.ttf', HEIGHT // 8 * 3 - HEIGHT // 8 * 1)
    text = smallfont.render('BLACKJACK', True, text_color)
    x = MARGIN
    y = HEIGHT // 8 * 1
    screen.blit(text, (x, y))


def display_middle_buttons(text_color, box_color1, box_color2, check, mouse, on_start, on_ad):
    text = [['START']]
    button_height, button_width = MARGIN * 4 // 1.15, MARGIN * 11
    x_start, x_end = MARGIN, MARGIN + button_width
    y_start, y_end = HEIGHT // 8 * 2.7, HEIGHT // 8 * 2.7 + button_height
    font, font_size = 'Corbel', round(button_height)
    button1 = display_supper_buttons(x_start, x_end, y_start, y_end, button_width, button_height, font,
                                     round(font_size / 1.15), text,
                                     text_color, box_color1, box_color2, mouse, check, on_start)

    text = [['ADD PLAYER'], ['DEL PLAYER']]
    button_height, button_width = MARGIN * 1.6, MARGIN * 4
    x_start, x_end = x_end + MARGIN, x_end + MARGIN + button_width
    y_start, y_end = HEIGHT // 8 * 2.7, HEIGHT // 8 * 2.7 + (MARGIN * 4) / 1.15
    font, font_size = 'Corbel', round(button_height // 3)
    # button_height /= 1.15
    button2 = display_supper_buttons(x_start, x_end, y_start, y_end, button_width, button_height, font, font_size, text,
                                     text_color, box_color1, box_color2, mouse, check, on_ad)
    return button1, button2


def middle_button_onoff():
    l1 = [[0]]
    l2 = [[0], [0]]
    if Player.total_players > 0:
        l1 = [[1]]
    if Player.total_players <= 4:
        l2[0][0] = 1
    if Player.total_players >= 1:
        l2[1][0] = 1
    return l1, l2

#name| nickname,passowrd,email,balance,total_games,+-,$won,$lost,putin,wins,losses,pushes,bj
def add_account(u_name, u_pass, email):
    with open(ACCOUNTS, 'a') as user_file:
        user_file.write(f"{u_name}| {u_pass},{email},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0}" + '\n')

def reset_current():
    add_data(SETTINGS, '0_0', 0, 4)
    add_data(SETTINGS, '', 0, 6)
    add_data(SETTINGS, '', 1, 6)
    add_data(SETTINGS, '', 2, 6)
    add_data(SETTINGS, '', 3, 6)
    add_data(SETTINGS, '', 4, 6)
    add_data(SETTINGS, '', 5, 6)
    add_data(SETTINGS, '', 6, 6)
    add_data(SETTINGS, '', 7, 6)
    #for i in range(3):
        #add_data(SETTINGS, '', int(current_list[i][:current_list[i].index("_")]),
                 #int(current_list[i][current_list[i].index("_") + 1:]))
    #add_data(SETTINGS, '', 0, 4)
# next use the name list and add data to the at account at the end of every game

def check_input(good_before, stuff, the_check):
    bad = "|()/,}{[] "
    print(the_check, stuff)
    if the_check == "name":
        if len(stuff) < 3:
            return False, "To Short"
        for char in bad:
            if char in stuff:
                return False, "Invalid Charters"
        if get_line(ACCOUNTS, stuff) is not False:
            return False, "Username not available"
        good_before = True if good_before else False
        return good_before, ""
    elif the_check == "pass":
        for char in bad:
            if char in stuff:
                return False, "Invalid Charters"
        if len(stuff) < 6:
            return False, "To Short"
        upper, lower, num, special = 0,0,0,0
        for char in stuff:
            upper += 1 if char.isupper() else 0
            lower += 1 if char.islower() else 0
            num += 1 if char in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] else 0
            special += 1 if char in ["?", "!", "@", "#", "$", "%", "^", "&", "*", "-", "+", "=", ",", ">", "<", ";",
                                     ":", "~", "`"] else 0
        if lower == 0 or upper == 0 or num == 0:
            text = "Uppercase" if upper == 0 else "Lowercase" if lower == 0 else "Number"
            return False, f"Missing {text}"
        # print(check_end)
        good_before = True if good_before else False
        return good_before, ""
    else:
        good_before = True if good_before else False
        return good_before, ""

def create_screen(player_dict,name_list, x_start, y_start, x_end, y_end):
    text_color, box_color1, box_color2, box_color3, trans_1 = WHITE, BLACK, GRAY, (94, 93, 93), TRANS_GRAY
    button_text1, on1 = [['LEAVE', 'ENTER']], [[1,1]]
    #button_text1, on1 = [['','LEAVE','', 'ENTER']], [[1, 1]]
    #button_text1, on1 = [['','LEAVE'],['','ENTER']], [[0,1],[0,1]]
    #button_text1, on1 = [['LEAVE'],[ 'ENTER']], [[1],[1]]
    the_mouse = (0, 0)
    font, font_size1, font_size2 = "Corbel", round(MARGIN//2), round(MARGIN)
    surface_width, surface_height = x_end - x_start, y_end - y_start
    button_height2, button_width2 = MARGIN, MARGIN*2
    top_xs, top_xe, top_ys, top_ye = x_start + MARGIN // 4, x_end - MARGIN//4, y_start + MARGIN // 4, y_end-MARGIN//4
    #add_data(SETTINGS, '2_5', 0, 4)
    current_list = ["0_6", "1_6", "2_6"]
    text_list = ["Username", "Password", "Email (optional)"]
    error_list = ["","",""]
    smallfont = pygame.font.SysFont('Corbel', font_size1)
    name_pass_email = False
    y_add = surface_height - MARGIN*len(current_list) - MARGIN*2.5
    while True:
        pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])
        leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                              font_size1, button_text1, text_color, box_color1, box_color2, the_mouse,
                                              False, on1)
        clicked, locked, check, mouse, ev, y = 0, False, False, (0, 0), None, y_start+MARGIN*2

        for i in range(3):
            locked = False
            current = current_list[i]
            clicked += text_box(x_start + MARGIN * 2, y, surface_width - MARGIN * 4, MARGIN, font,
                                font_size2, mouse, ev, check, current, 0, 'str', locked, SETTINGS)
            the_text = text_list[i] if error_list[i] == '' else error_list[i]
            text = smallfont.render(the_text, True, WHITE)
            text_rect = text.get_rect(center=((surface_width) // 2 + x_start, (surface_height) // 2 + y-MARGIN*3.8))
            screen.blit(text, text_rect)
            y += y_add
        leave = False
        on1[0][1] = 1 if name_pass_email is True else 0
        for ev in pygame.event.get():
            mouse, the_mouse, check = pygame.mouse.get_pos(), pygame.mouse.get_pos(), ev.type == pygame.MOUSEBUTTONDOWN

            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,font_size1, button_text1,text_color, box_color1, box_color2, mouse, check, on1)

            if leave_button != None:
                if leave_button == (0,0):
                    leave = True
                else:
                    add_account(get_data(SETTINGS, 0,6), get_data(SETTINGS, 1,6), get_data(SETTINGS, 2,6))
                    name = get_data(SETTINGS, 0,6)
                    reset_current()
                    print(name)
                    del_add_player('add', player_dict, name_list, name)
                    pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
                    print("done")
                    return True
            clicked, locked, y = 0, False, y_start+MARGIN*2
            for i in range(3):
                locked = False
                current = current_list[i]
                clicked += text_box(x_start + MARGIN*2, y, surface_width-MARGIN*4, MARGIN, font,
                                    font_size2, mouse, ev, check, current, 0, 'str', locked, SETTINGS)
                #text = smallfont.render(text_list[i], True, WHITE)
                #text_rect = text.get_rect(center=((surface_width) // 2 + x_start, (surface_height) // 2 + y - MARGIN*4))
                #screen.blit(text, text_rect)
                y += y_add
            if clicked == 0:
                add_data(SETTINGS, '0_0', 0, 4)
            none_pressed = True if None in [leave_button] else False
            if none_pressed and (ev.type == pygame.MOUSEBUTTONDOWN and (mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                leave = True
                break

        if leave is True:
            pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
            reset_current()
            print("leave")
            return False

        checks = ["name","pass","email"]
        name_pass_email = True if get_data(SETTINGS, 0, 4) == "0_0" else False
        for i in range(3):
            error_list[i] = ""
            if get_data(SETTINGS, 0, 4) != current_list[i]:
                current = current_list[i]
                num1 = int(current[:current.index('_')])
                num2 = int(current[current.index('_') + 1:])
                if len(get_data(SETTINGS, num1, num2)) > 0:
                    name_pass_email, error_list[i] = check_input(name_pass_email, get_data(SETTINGS, num1, num2), checks[i])
                elif i != 2:
                    name_pass_email = False
                    #thing = check_input(name_pass_email, get_data(SETTINGS, num1, num2), checks[i])
                    #print(thing)

            pygame.display.update()

def login_screen(player_dict, x_start, y_start, x_end, y_end):
    text_color, box_color1, box_color2, box_color3, trans_1 = WHITE, BLACK, GRAY, (94, 93, 93), TRANS_GRAY
    button_text1, on1 = [['LEAVE', 'ENTER'],['', 'FORGOT']], [[1, 1], [0,0]]
    # button_text1, on1 = [['','LEAVE','', 'ENTER']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE'],['','ENTER']], [[0,1],[0,1]]
    # button_text1, on1 = [['LEAVE'],[ 'ENTER']], [[1],[1]]
    the_mouse = (0, 0)
    font, font_size1, font_size2 = "Corbel", round(MARGIN // 2), round(MARGIN)
    surface_width, surface_height = x_end - x_start, y_end - y_start
    button_height2, button_width2 = MARGIN, MARGIN * 2
    top_xs, top_xe, top_ys, top_ye = x_start + MARGIN // 4, x_end - MARGIN // 4, y_start + MARGIN // 4, y_end - MARGIN // 4
    #add_data(SETTINGS, '2_5', 0, 4)
    static_dict = {"user_name": "", "password": ""}
    current_list = ["0_6", "1_6"]
    text_list = ["Username", "Password"]
    error_list = ["", ""]
    smallfont = pygame.font.SysFont('Corbel', font_size1)
    name_pass_email = False
    y_add = surface_height - MARGIN * len(current_list) - MARGIN * 3.25
    while True:
        pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])
        leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                              font_size1, button_text1, text_color, box_color1, box_color2, the_mouse,
                                              False, on1)
        clicked, locked, check, mouse, ev, y = 0, False, False, (0, 0), None, y_start + MARGIN * 2.25

        for i in range(2):
            locked = False
            current = current_list[i]
            clicked += text_box(x_start + MARGIN * 2, y, surface_width - MARGIN * 4, MARGIN, font,
                                font_size2, mouse, ev, check, current, 0, 'str', locked, SETTINGS)
            the_text = text_list[i] if error_list[i] == '' else error_list[i]
            text = smallfont.render(the_text, True, WHITE)
            text_rect = text.get_rect(center=((surface_width) // 2 + x_start, (surface_height) // 2 + y - MARGIN * 3.8))
            screen.blit(text, text_rect)
            y += y_add
        leave = False
        on1[0][1] = 1 if name_pass_email is True else 0
        for ev in pygame.event.get():
            mouse, the_mouse, check = pygame.mouse.get_pos(), pygame.mouse.get_pos(), ev.type == pygame.MOUSEBUTTONDOWN

            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                                  font_size1, button_text1, text_color, box_color1, box_color2, mouse,
                                                  check, on1)

            if leave_button != None:
                if leave_button == (0, 0):
                    leave = True
                else:
                    name = get_data(SETTINGS, 0, 6)
                    reset_current()
                    del_add_player('add', player_dict, [], name)
                    pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
                    print("done")
                    return True
            clicked, locked, y = 0, False, y_start + MARGIN * 2.25
            for i in range(2):
                locked = False
                current = current_list[i]
                clicked += text_box(x_start + MARGIN * 2, y, surface_width - MARGIN * 4, MARGIN, font,
                                    font_size2, mouse, ev, check, current, 0, 'str', locked, SETTINGS)
                # text = smallfont.render(text_list[i], True, WHITE)
                # text_rect = text.get_rect(center=((surface_width) // 2 + x_start, (surface_height) // 2 + y - MARGIN*4))
                # screen.blit(text, text_rect)
                y += y_add
            if clicked == 0:
                add_data(SETTINGS, '0_0', 0, 4)
            none_pressed = True if None in [leave_button] else False
            if none_pressed and (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                leave = True
                break

        if leave is True:
            pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
            reset_current()
            print("leave")
            return False

        checks = ["name", "pass"]
        name_pass_email = True if get_data(SETTINGS, 0, 4) == "0_0" else False
        for i in range(2):
            error_list[i] = ""

            if get_data(SETTINGS, 0, 4) != current_list[i]:

                current = current_list[i]
                num1 = int(current[:current.index('_')])
                num2 = int(current[current.index('_') + 1:])
                #print(current)
                if len(get_data(SETTINGS, num1, num2)) > 0:
                    if checks[i] == 'name':
                        name_in_game = False
                        for a in range(Player.total_players):
                            p = Player.player_list[i]
                            current_player_name = player_dict[f"user_{p}"]["name"]
                            if current_player_name == get_data(SETTINGS, 0, 6):
                                name_in_game = True
                                break

                        if get_line(ACCOUNTS, get_data(SETTINGS, 0, 6)) is not False and " " not in get_data(SETTINGS, 0, 6) and not name_in_game:
                            name_pass_email = True if name_pass_email else False
                        elif get_line(ACCOUNTS, get_data(SETTINGS, 0, 6)) is False or " " in get_data(SETTINGS, 0, 6):
                            name_pass_email, error_list[i] = False, "No User Found"
                        elif name_in_game:
                            name_pass_email, error_list[i] = False, "User Already In Game"
                        #print(error_list[i], name_in_game, name_pass_email, get_line(ACCOUNTS, get_data(SETTINGS, 0, 6)))
                    elif checks[i] == 'pass':
                        if get_line(ACCOUNTS, get_data(SETTINGS, 0, 6)):
                            #print(get_data(ACCOUNTS, 0, get_line(ACCOUNTS, get_data(SETTINGS, 0, 6))))
                            if get_data(SETTINGS, 1, 6) == get_data(ACCOUNTS, 0, get_line(ACCOUNTS, get_data(SETTINGS, 0, 6))):
                                name_pass_email = True if name_pass_email else False
                            else:
                                name_pass_email, error_list[i] = False, "Incorrect Password"
                    # thing = check_input(name_pass_email, get_data(SETTINGS, num1, num2), checks[i])
                    # print(thing)
                else:
                    name_pass_email = False
            pygame.display.update()
def all_account_data(key, current_player):
    blank = []
    for i in range(0,12):
        blank.append(get_data(ACCOUNTS, i, get_line(ACCOUNTS, current_player["name"])))
    return blank
def account_info_screen(player_dict, x_start, y_start, x_end, y_end, current_player, t):
    text_color, box_color1, box_color2, box_color3, trans_1 = WHITE, BLACK, GRAY, (94, 93, 93), TRANS_GRAY
    if " " not in current_player["name"]:
        button_text1, on1 = [['','','Edit Info'],['','Exit','']], [[0,0,1],[0,1,0]]
    else:
        button_text1, on1 = [['','',''],['','Exit','']], [[0,0,0],[0,1,0]]
    # button_text1, on1 = [['','LEAVE','', 'ENTER']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE'],['','ENTER']], [[0,1],[0,1]]
    # button_text1, on1 = [['LEAVE'],[ 'ENTER']], [[1],[1]]
    key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5, "$lost": 6, "putin": 7,
           "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
    data_list = all_account_data(key, current_player)
    #print(data_list)
    on = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]
    #print(data_list[key["bj"]])
    text = [['Balance',f'${data_list[key["balance"]]}','Hands Played',f'{data_list[key["total_games"]]}'], ['+-',f'${data_list[key["+-"]]}','Hands Won',f'{data_list[key["wins"]]}'], ['Winnings',f'${data_list[key["$won"]]}','Hands Lost',f'{data_list[key["losses"]]}'], ['Losses',f'${data_list[key["$lost"]]}','Hands Pushed',f'{data_list[key["pushes"]]}'], ['Putin',f'${data_list[key["putin"]]}','BlackJack',f'{data_list[key["bj"]]}']]
    button_height, button_width = MARGIN * 2, MARGIN * 5
    button_height2, button_width2 = MARGIN, MARGIN * 2
    x_s, x_e = x_start + MARGIN, x_end - MARGIN
    y_s, y_e = y_start + MARGIN*1.5, y_end - MARGIN*1.5
    #font, font_size = 'Corbel', button_height // 2

    the_mouse = (0, 0)
    font, font_size1, font_size2 = "Corbel", round(MARGIN // 2), round(MARGIN //2)
    surface_width, surface_height = x_end - x_start, y_end - y_start
    button_height2, button_width2 = MARGIN, MARGIN * 2
    top_xs, top_xe, top_ys, top_ye = x_start + MARGIN // 4, x_end - MARGIN // 4, y_start + MARGIN // 4, y_end - MARGIN // 4
    while True:
        pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])
        leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                              font_size1, button_text1, text_color, box_color1, box_color2, the_mouse,
                                              False, on1)

        button1 = display_supper_buttons(x_s, x_e, y_s, y_e, button_width2, button_height2, font, font_size2, text,
                                         WHITE, box_color3, box_color3, the_mouse, False, on)

        smallfont = pygame.font.SysFont('freesansbold.ttf', round(MARGIN))
        name = current_player["name"]
        a_text = smallfont.render(f'{name} - INFO', True, BLACK)
        the_surface = surface_width - MARGIN * 3 if " " not in current_player["name"] else surface_width
        text_rect = a_text.get_rect(
            center=((the_surface) // 2 + x_start, (MARGIN//4+MARGIN) // 2 + y_start+MARGIN//4))
        screen.blit(a_text, text_rect)

        leave = False

        for ev in pygame.event.get():
            mouse, the_mouse, check = pygame.mouse.get_pos(), pygame.mouse.get_pos(), ev.type == pygame.MOUSEBUTTONDOWN

            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                                  font_size1, button_text1, text_color, box_color1, box_color2, mouse,
                                                  check, on1)
            leave = True if leave_button != None  and leave_button == (1,1) else False
            none_pressed = True if None in [leave_button] else False
            if none_pressed and (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                leave = True
                break

            if leave_button != None and leave_button == (0, 2):
                change = change_info_screen(player_dict, x_start, y_start, x_end, y_end, current_player, t)
                print(change)
                leave = True if change else False
                break
        if leave is True:
            pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
            print("leave")
            return False
        pygame.display.update()
def frogot_password_screen(player_dict, x_start, y_start, x_end, y_end):
    text_color, box_color1, box_color2, box_color3, trans_1 = WHITE, BLACK, GRAY, (94, 93, 93), TRANS_GRAY
    button_text1, on1 = [['LEAVE', 'ENTER']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE','', 'ENTER']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE'],['','ENTER']], [[0,1],[0,1]]
    # button_text1, on1 = [['LEAVE'],[ 'ENTER']], [[1],[1]]
    the_mouse = (0, 0)
    font, font_size1, font_size2 = "Corbel", round(MARGIN // 2), round(MARGIN)
    surface_width, surface_height = x_end - x_start, y_end - y_start
    button_height2, button_width2 = MARGIN, MARGIN * 2
    top_xs, top_xe, top_ys, top_ye = x_start + MARGIN // 4, x_end - MARGIN // 4, y_start + MARGIN // 4, y_end - MARGIN // 4
    while True:
        pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])
        leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                              font_size1, button_text1, text_color, box_color1, box_color2, the_mouse,
                                              False, on1)
        leave = False

        for ev in pygame.event.get():
            mouse, the_mouse, check = pygame.mouse.get_pos(), pygame.mouse.get_pos(), ev.type == pygame.MOUSEBUTTONDOWN

            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                                  font_size1, button_text1, text_color, box_color1, box_color2, mouse,
                                                  check, on1)
            leave = True if leave_button != None else False

            none_pressed = True if None in [leave_button] else False
            if none_pressed and (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                leave = True
                break

        if leave is True:
            pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
            print("leave")
            return False
        pygame.display.update()
def chack_password_screen(player_dict, x_start, y_start, x_end, y_end):
    text_color, box_color1, box_color2, box_color3, trans_1 = WHITE, BLACK, GRAY, (94, 93, 93), TRANS_GRAY
    button_text1, on1 = [['LEAVE', 'ENTER']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE','', 'ENTER']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE'],['','ENTER']], [[0,1],[0,1]]
    # button_text1, on1 = [['LEAVE'],[ 'ENTER']], [[1],[1]]
    the_mouse = (0, 0)
    font, font_size1, font_size2 = "Corbel", round(MARGIN // 2), round(MARGIN)
    surface_width, surface_height = x_end - x_start, y_end - y_start
    button_height2, button_width2 = MARGIN, MARGIN * 2
    top_xs, top_xe, top_ys, top_ye = x_start + MARGIN // 4, x_end - MARGIN // 4, y_start + MARGIN // 4, y_end - MARGIN // 4
    while True:
        pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])
        leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                              font_size1, button_text1, text_color, box_color1, box_color2, the_mouse,
                                              False, on1)
        leave = False

        for ev in pygame.event.get():
            mouse, the_mouse, check = pygame.mouse.get_pos(), pygame.mouse.get_pos(), ev.type == pygame.MOUSEBUTTONDOWN

            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                                  font_size1, button_text1, text_color, box_color1, box_color2, mouse,
                                                  check, on1)
            leave = True if leave_button != None else False

            none_pressed = True if None in [leave_button] else False
            if none_pressed and (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                leave = True
                break

        if leave is True:
            pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
            print("leave")
            return False
        pygame.display.update()
def plop_data(cur_player, line, name):
    key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5, "$lost": 6, "putin": 7,
           "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
    current_list = ["0_6", "1_6", "2_6", "3_6", "4_6", "5_6", "6_6", "7_6"]

    key_list = ["name","password","email","balance","name","password","email","balance"]
    for i in range(len(current_list)):
        current = current_list[i]
        num1 = int(current[:current.index('_')])
        num2 = int(current[current.index('_') + 1:])
        if key_list[i] == "name":
            add_data(SETTINGS, name, num1, num2)
        else:
            the_data = get_data(ACCOUNTS, key[key_list[i]], line)
            add_data(SETTINGS, str(the_data), num1, num2)
def change_name(new_name, line, file):
    with open(file, 'r') as the_file:
        the_lines = the_file.readlines()
    current_line = the_lines[line]
    old_data = current_line[current_line.index("|"):]
    new_line = new_name+old_data
    the_lines[line] = new_line
    with open(file, 'w') as the_file:
        for i in range(len(the_lines)):
            the_file.write(the_lines[i])
def plop_new_data(the_type, line, player_dict, cur_player, t):
    key = {"password": 0, "email": 1, "balance": 2, "total_games": 3, "+-": 4, "$won": 5, "$lost": 6, "putin": 7,
           "wins": 8, "losses": 9, "pushes": 10, "bj": 11}
    current_list = ["0_6", "1_6", "2_6", "3_6", "4_6", "5_6", "6_6", "7_6"]

    key_list = ["name", "password", "email", "balance", "name", "password", "email", "balance"]
    for i in range(len(current_list)//2):
        current = current_list[i]
        num1 = int(current[:current.index('_')])
        num2 = int(current[current.index('_') + 1:])
        num1 += 4 if the_type == "old" else 0
        if key_list[i] == "name":
            the_data = get_data(SETTINGS, num1, num2)
            change_name(the_data, line, ACCOUNTS)
        elif key_list[i] == "balance":
            add_data(ACCOUNTS, '', key[key_list[i]], line)
            the_data = get_data(SETTINGS, num1, num2)
            add_data(ACCOUNTS, str(the_data), key[key_list[i]], line)
            if the_type == "new":
                print(the_data - get_data(SETTINGS, 7, 6), " here")
                print(the_data, get_data(SETTINGS, 7, 6), )
                back_data = get_data(ACCOUNTS, key["putin"], line)

                if the_data > get_data(SETTINGS, 7, 6):
                    back_data = the_data - get_data(SETTINGS, 7, 6)
                    print(back_data)
                    #add_data(ACCOUNTS, '', key["putin"], line)
                    add_data(ACCOUNTS, back_data, key["putin"], line)
                else:
                    back_data += the_data - get_data(SETTINGS, 7, 6)
                    print(back_data)
                    print(the_data-get_data(SETTINGS, 7, 6), " here")
                    add_data(ACCOUNTS, '', key["putin"], line)
                    add_data(ACCOUNTS, str(back_data), key["putin"], line)
        else:
            the_data = get_data(SETTINGS, num1, num2)
            add_data(ACCOUNTS, str(the_data), key[key_list[i]], line)
    if the_type == "new":
        del_add_player(t, player_dict, [], cur_player["name"])
        del_add_player("add", player_dict, [], cur_player["name"])

def change_info_screen(player_dict, x_start, y_start, x_end, y_end, cur_player, t):
    text_color, box_color1, box_color2, box_color3, trans_1 = WHITE, BLACK, GRAY, (94, 93, 93), TRANS_GRAY
    button_text1, on1 = [['CANSEL', 'SAVE']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE','', 'ENTER']], [[1, 1]]
    # button_text1, on1 = [['','LEAVE'],['','ENTER']], [[0,1],[0,1]]
    # button_text1, on1 = [['LEAVE'],[ 'ENTER']], [[1],[1]]
    line = get_line(ACCOUNTS, cur_player["name"])
    the_mouse = (0, 0)
    font, font_size1, font_size2 = "Corbel", round(MARGIN // 2), round(MARGIN)
    surface_width, surface_height = x_end - x_start, y_end - y_start
    button_height2, button_width2 = MARGIN, MARGIN * 2
    top_xs, top_xe, top_ys, top_ye = x_start + MARGIN // 4, x_end - MARGIN // 4, y_start + MARGIN // 4, y_end - MARGIN // 4
    current_list = ["0_6", "1_6", "2_6", "3_6"]
    text_list = ["Username", "Password", "Email (optional)"]
    error_list = ["", "", ""]
    smallfont = pygame.font.SysFont('Corbel', font_size1)
    name_pass_email = False
    new_data = False
    y_add = surface_height - MARGIN * len(current_list) - MARGIN*1.5
    plop_data(cur_player, line, cur_player["name"])
    while True:
        pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])
        leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                              font_size1, button_text1, text_color, box_color1, box_color2, the_mouse,
                                              False, on1)
        clicked, locked, check, mouse, ev, y = 0, False, False, (0, 0), None, y_start + MARGIN * 1.5
        type_list = ['str','str','str','int']
        for i in range(4):
            locked = False
            current = current_list[i]
            if i < 3:
                start, the_width = x_start + MARGIN * 2, surface_width - MARGIN * 4
            else:
                start, the_width = x_start + MARGIN * 4.5, MARGIN * 5.5
                y -= y_add // 3
                locked = True
            clicked += text_box(start, y, the_width, MARGIN, font,
                                font_size2, mouse, ev, check, current, 1000000, type_list[i], locked, SETTINGS)
            if i < 3:
                the_text = text_list[i] if error_list[i] == '' else error_list[i]
                text = smallfont.render(the_text, True, WHITE)
                text_rect = text.get_rect(center=((surface_width) // 2 + x_start, (surface_height) // 2 + y - MARGIN * 3.8))
                screen.blit(text, text_rect)
            else:
                thefont = pygame.font.SysFont('freesansbold.ttf', MARGIN)
                text = thefont.render('Balance', True, BLACK)
                text_rect = text.get_rect(
                    center=((surface_width) // 2 + x_start, (MARGIN) // 2 + y))
                screen.blit(text, (x_start+MARGIN,text_rect[1]))
            y += y_add
        leave = False

        for ev in pygame.event.get():
            mouse, the_mouse, check = pygame.mouse.get_pos(), pygame.mouse.get_pos(), ev.type == pygame.MOUSEBUTTONDOWN

            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                                  font_size1, button_text1, text_color, box_color1, box_color2, mouse,
                                                  check, on1)

            if leave_button != None:
                if leave_button == (0,0):
                    leave = True
                    new_data = False
                else:
                    leave = True
                    new_data = True
            else:
                leave = False
            clicked, locked, y = 0, False, y_start + MARGIN * 1.5
            type_list = ['str', 'str', 'str', 'int']
            for i in range(4):
                locked = False
                current = current_list[i]
                if i < 3:
                    start, the_width = x_start + MARGIN * 2, surface_width - MARGIN * 4
                else:
                    locked = True
                    start, the_width = x_start + MARGIN * 4.5, MARGIN * 5.5
                    y -= y_add // 3
                clicked += text_box(start, y, the_width, MARGIN, font,
                                    font_size2, mouse, ev, check, current, 1000000, type_list[i], locked, SETTINGS)

                y += y_add
            if clicked == 0:
                add_data(SETTINGS, '0_0', 0, 4)
            none_pressed = True if None in [leave_button] else False
            if none_pressed and (ev.type == pygame.MOUSEBUTTONDOWN and (
                    mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                new_data = False
                leave = True
                break

        if leave is True:
            pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
            if new_data:
                plop_new_data('new', line, player_dict, cur_player, t)
            else:
                plop_new_data('old', line, player_dict, cur_player, t)
            reset_current()
            print("leave")
            return new_data

        checks = ["name", "pass", "email"]
        name_pass_email = True if get_data(SETTINGS, 0, 4) == "0_0" else False
        for i in range(3):
            error_list[i] = ""
            if get_data(SETTINGS, 0, 4) != current_list[i]:
                current = current_list[i]
                num1 = int(current[:current.index('_')])
                num2 = int(current[current.index('_') + 1:])
                if get_data(SETTINGS, num1, num2) != get_data(SETTINGS, num1 + 4, num2):
                    if len(get_data(SETTINGS, num1, num2)) > 0:
                        name_pass_email, error_list[i] = check_input(name_pass_email, get_data(SETTINGS, num1, num2),checks[i])
                    else:
                        name_pass_email = False

        num2 = 6
        info_has_changed = False
        for i in range(4):
            if get_data(SETTINGS, i, num2) != get_data(SETTINGS, i+4, num2):
                #print(get_data(SETTINGS, i, num2), get_data(SETTINGS, i+4, num2))
                info_has_changed = True
                break
            else:
                info_has_changed = False
        #print(info_has_changed, name_pass_email)
        if info_has_changed and name_pass_email:
            on1[0][1] = 1
        else:
            on1[0][1] = 0
        pygame.display.update()



def add_screen(player_dict, name_list):
    text_color = WHITE
    box_color1 = BLACK
    box_color2 = GRAY
    box_color3 = (94, 93, 93)
    trans1 = TRANS_GRAY
    button_height, button_width = MARGIN*2, MARGIN * 4
    button_height2, button_width2 = MARGIN, MARGIN*2
    button_text1 = [['LEAVE']]
    on1 = [[1]]
    button_text2 = [['CREATE', 'GUEST']]
    on2 = [[1,1]]
    button_text3 = [['LOGIN']]
    on3 = [[1]]

    font, font_size1, font_size2 = "Corbel", round(MARGIN//2), round(MARGIN)

    x_start, y_start = WIDTH // 10 * 3, HEIGHT // 10 * 3
    x_end, y_end = WIDTH // 10 * 7, HEIGHT // 10 * 7
    surface_width, surface_height = x_end - x_start, y_end - y_start

    top_xs, top_xe, top_ys, top_ye = x_start + MARGIN//4, x_end - MARGIN, y_start + MARGIN// 4, y_start + MARGIN//4 + button_height2
    middle_xs, middle_xe, middle_ys, middle_ye = x_start + MARGIN * 2, x_end - MARGIN*2,y_start+surface_height//2- button_height//2- MARGIN, y_end
    botton_xs, bottom_xe, bottom_ys, bottom_ye = surface_width//2 + x_start - button_width//2, surface_width//2 + y_start + button_width +MARGIN, y_end - MARGIN-button_height, y_end-MARGIN*4

    the_mouse = (0,0)

    while True:
        pygame.draw.rect(screen, box_color3, [x_start, y_start, surface_width, surface_height])

        leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,
                                              font_size1, button_text1, text_color, box_color1, box_color2, the_mouse,
                                              False, on1)
        middle_buttons = display_supper_buttons(middle_xs, middle_xe, middle_ys, middle_ye, button_width, button_height,
                                                font, font_size2, button_text2, text_color, box_color1, box_color2,
                                                the_mouse, False, on2)
        bottom_buttons = display_supper_buttons(botton_xs, bottom_xe, bottom_ys, bottom_ye, button_width, button_height,
                                                font, font_size2, button_text3, text_color, box_color1, box_color2,
                                                the_mouse, False, on3)
        leave = False
        did = False
        for ev in pygame.event.get():
            change = True
            mouse = pygame.mouse.get_pos()
            the_mouse = mouse
            check = ev.type == pygame.MOUSEBUTTONDOWN
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            leave_button = display_supper_buttons(top_xs, top_xe, top_ys, top_ye, button_width2, button_height2, font,font_size1, button_text1,text_color, box_color1, box_color2, mouse, check, on1)

            middle_buttons = display_supper_buttons(middle_xs, middle_xe, middle_ys, middle_ye, button_width, button_height, font,font_size2, button_text2,text_color, box_color1, box_color2, mouse, check, on2)

            bottom_buttons = display_supper_buttons(botton_xs, bottom_xe, bottom_ys, bottom_ye, button_width, button_height, font,font_size2, button_text3,text_color, box_color1, box_color2, mouse, check, on3)

            if None in [leave_button,middle_buttons,bottom_buttons]:
                none_pressed = True
            else:
                none_pressed = False

            if leave_button != None:
                leave = True
                break
            elif middle_buttons != None:
                if middle_buttons == (0, 0):
                    print("create")
                    did = create_screen(player_dict,name_list, x_start, y_start, x_end, y_end)
                    leave = True if did else False
                    break
                else:
                    print("guest")
                    num = get_list_num()
                    del_add_player("guest", player_dict, name_list, f"PLAYER {num}")
                    leave = True
                    break
            elif bottom_buttons != None:
                print("login")
                did = login_screen(player_dict, x_start, y_start, x_end, y_end)
                leave = True if did else False
                break
            if none_pressed and (ev.type == pygame.MOUSEBUTTONDOWN and (mouse[0] < x_start or mouse[0] > x_end or mouse[1] < y_start or mouse[1] > y_end)):
                leave = True
                break
        if leave is True:
            pygame.draw.rect(screen, GREEN, [x_start, y_start, surface_width, surface_height])
            print("leave")
            return did
        pygame.display.update()



def delete_screen(text_color, box_color1, box_color2, player_list, name_list):
    # future is red transparent boxes and if you click anywhere else or cansel you quit
    top2 = HEIGHT // 10 * 7 + MARGIN
    top = HEIGHT // 10 * 7
    x_add = WIDTH // Player.total_players
    x = 0
    trans2 = TRANS_RED
    # for i in range(Player.total_players):
    # draw_rect_alpha(screen, trans2, (x, top2, x + x_add, HEIGHT))
    # x += x_add
    draw_rect_alpha(screen, TRANS_GRAY, (0, 0, WIDTH, top))
    draw_rect_alpha(screen, trans2, (x, top2, WIDTH, HEIGHT - top2))

    while True:
        for ev in pygame.event.get():
            check = ev.type == pygame.MOUSEBUTTONDOWN
            mouse = pygame.mouse.get_pos()

            text = [[''], ['CANCEL']]
            button_height, button_width = MARGIN * 1.6, MARGIN * 4
            x_start, x_end = MARGIN * 12 + MARGIN, MARGIN * 12 + MARGIN + button_width
            y_start, y_end = HEIGHT // 8 * 2.7, HEIGHT // 8 * 2.7 + (MARGIN * 4) / 1.15
            font, font_size = 'Corbel', round(button_height // 3)

            # button_height /= 1.15
            button2 = display_supper_buttons(x_start, x_end, y_start, y_end, button_width, button_height, font,
                                             font_size, text, text_color, box_color1, box_color2, mouse, check,
                                             [[0], [1]])
            if button2 == (1, 0):
                return player_list

            top2 = HEIGHT // 10 * 7 + MARGIN
            x_add = WIDTH // Player.total_players
            x = 0
            for i in range(Player.total_players):
                t = Player.player_list[i]
                if x <= mouse[0] <= x + x_add and top2 <= mouse[1] <= HEIGHT and check:
                    guest_list = [f"PLAYER {k}" for k in range(1, 6)]
                    name = "player" if player_list[f"user_{t}"]["name"] in guest_list else "none"
                    print(player_list[f"user_{t}"]["name"]+" " + str(t) in guest_list, name, t)

                    del_add_player(t, player_list, name_list, name)
                    # print(button)
                    # print("here")
                    return player_list
                x += x_add
        pygame.display.update()


def display_players(player_list, mouse, check):
    tan = (176, 157, 106)
    tan1 = (179, 165, 129)
    fill_col = (163, 189, 162)
    pla_bx_col = (129, 145, 128)
    text_color = (77, 73, 94)
    top = HEIGHT // 10 * 7
    trans1 = TRANS_WHITE
    x_start, y_start = WIDTH // 10 * 3, HEIGHT // 10 * 3
    x_end, y_end = WIDTH // 10 * 7, HEIGHT // 10 * 7
    pygame.draw.rect(screen, fill_col, [0, top, WIDTH, HEIGHT])
    if Player.total_players > 0:
        top2 = HEIGHT // 10 * 7 + MARGIN
        x_add = WIDTH // Player.total_players
        x = 0
        # print(Player.total_players)
        for i in range(Player.total_players):
            t = Player.player_list[i]
            # print(player_list, player_list[f"user_{i}"]["balance"])
            pygame.draw.rect(screen, pla_bx_col, [x, top2, x + x_add, HEIGHT])
            smallfont = pygame.font.SysFont('freesansbold.ttf', MARGIN)
            name = player_list[f"user_{t}"]["name"] + f" {t}" if player_list[f"user_{t}"]["name"] == "PLAYER" else \
                player_list[f"user_{t}"]["name"]
            text = smallfont.render(name, True, text_color)
            text_rect = text.get_rect(center=(((x + x_add - x) + x * 2) // 2, ((top2 - top) // 2) + top))
            # print(text_rect)
            screen.blit(text, text_rect)
            smallfont = pygame.font.SysFont('freesansbold.ttf', (HEIGHT - top2) // Player.total_players)
            text = smallfont.render("$" + str(player_list[f"user_{t}"]["balance"]), True, text_color)
            text_rect = text.get_rect(
                center=(((x + x_add - x) + x * 2) // 2, ((HEIGHT - top) // 2) + top2 - MARGIN // 2))
            screen.blit(text, text_rect)

            if x <= mouse[0] <= x + x_add and top <= mouse[1] <= HEIGHT:
                draw_rect_alpha(screen, trans1, (x, top, x_add, HEIGHT-top))
                if check:
                    account_info_screen(player_list, x_start, y_start, x_end, y_end, player_list[f"user_{t}"], t)
            x += x_add
        pygame.draw.line(screen, BLACK, (0, top + MARGIN), (WIDTH, top + MARGIN), MARGIN // 6)

    pygame.draw.line(screen, BLACK, (0, top), (WIDTH, top), MARGIN // 6)

    for i in range(Player.total_players - 1):
        x_start = (WIDTH // (Player.total_players)) * (i + 1)
        pygame.draw.line(screen, BLACK, (x_start, top), (x_start, HEIGHT), MARGIN // 6)


def display_cool_card(card, angle):
    card_height = (HEIGHT // 10 * 7 - MARGIN * 4) / 1.15
    card_width = card_height // 1.38
    x = WIDTH // 10 * 7
    # x = 0
    y = MARGIN * 2
    #angle_add = 1.25
    angle_add = 3.75

    load_text = r'other/background.png'
    next_card = pygame.image.load(load_text)
    next_card = pygame.transform.scale(next_card, (card_width, card_height))
    next_card = pygame.transform.rotate(next_card, angle)
    screen.blit(next_card, (x, y))
    pygame.draw.rect(screen, GREEN, [x, y, WIDTH - x, HEIGHT // 10 * 7 - y - MARGIN * 1.38])
    new_angle = angle + angle_add if card != ['8', 'Hearts'] else angle - angle_add

    card = card.split()
    load_text = decode_cards(card)
    next_card = pygame.image.load(load_text)
    next_card = pygame.transform.scale(next_card, (card_width, card_height))
    next_card = pygame.transform.rotate(next_card, new_angle)
    screen.blit(next_card, (x, y))
    return new_angle


def populate_chips():
    chip_list = [r'chips/chip_biege_top_large.png', r'chips/chip_black_top_large.png', r'chips/chip_red_top_large.png',
                 r'chips/chip_gray_top_large.png', r'chips/chip_blue_top_large.png', r'chips/chip_green_top_large.png',
                 r'chips/chip_white_top_large.png', r'chips/chip_yellow_top_large.png',
                 r'chips/chip_pink_top_large.png', r'chips/chip_lightblue_top_large.png',
                 r'chips/chip_purple_top_large.png']
    x = random.randint(0 - MARGIN, WIDTH)
    y = random.randint(round(HEIGHT // 10 * 6.25), HEIGHT)
    # y = random.randint(0, HEIGHT)

    load_chip = pygame.image.load(random.choice(chip_list))
    load_chip = pygame.transform.scale(load_chip, (MARGIN, MARGIN))
    load_chip = pygame.transform.rotate(load_chip, 0)
    screen.blit(load_chip, (x, y))


def menu():
    bg_color = GREEN
    screen = make_window(bg_color, 'BLACKJACK MENU')
    txt_col = WHITE
    bx_col1 = BLACK
    bx_col2 = GRAY
    trans1 = TRANS_GRAY
    trans2 = TRANS_WHITE
    top_buttons_onoff = [[1, 1]]
    middle_buttons_onoff_start = [[1]]
    middle_buttons_onoff_ad = [[1], [1]]
    player_dict = {}
    name_list = {}
    Player.total_players = 0
    menu_deck = make_52()
    menu_card = random.choice(menu_deck)
    menu_angle = 0
    clean_screen = False
    the_mouse = (0, 0)
    # clean_players = False
    while True:
        for ev in pygame.event.get():
            mouse = pygame.mouse.get_pos()
            the_mouse = mouse
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            # displays buttons
            button = menu_buttons_top(txt_col, bx_col1, bx_col2, ev.type == pygame.MOUSEBUTTONDOWN, mouse,
                                      top_buttons_onoff)
            # print(flip, button)
            if button != None:
                if button == (0, 0):
                    setting_window(trans1, DARK_GRAY)
                    screen.fill(bg_color)
                if button == (0, 1):
                    for i in range(Player.total_players):
                        t = Player.player_list[0]
                        guest_list = [f"PLAYER {k}" for k in range(1, 6)]
                        name = "player" if player_dict[f"user_{t}"]["name"] in guest_list else "none"
                        del_add_player(t, player_dict, name_list, name)
                    pygame.quit()
                    sys.exit()
            display_bj_text(BLACK)
            middle_buttons_onoff_start, middle_buttons_onoff_ad = middle_button_onoff()
            b1, b2 = display_middle_buttons(txt_col, bx_col1, bx_col2, ev.type == pygame.MOUSEBUTTONDOWN, mouse,
                                            middle_buttons_onoff_start, middle_buttons_onoff_ad)
            if b1 or b2 != None:
                if b1 == (0, 0):
                    cool = game(bg_color, Player.total_players, player_dict, name_list)
                    print(cool)
                    menu_card = random.choice(menu_deck)
                    screen.fill(bg_color)
                    clean_screen = True
                if b2 == (0, 0):
                    show_player = add_screen(player_dict, name_list)
                    print(show_player)
                    # player_dict[f'f"user_{Player.player_list[-1]}']["balance"] = get_data(SETTINGS, 1, 1)
                if b2 == (1, 0):
                    player_dict = delete_screen(txt_col, bx_col1, bx_col2, player_dict, name_list)
                    screen.fill(bg_color)

            if Player.total_players:
                display_players(player_dict, mouse, ev.type == pygame.MOUSEBUTTONDOWN)

        if Player.total_players == 0:
            populate_chips()
        menu_angle = display_cool_card(menu_card, menu_angle)
        button = menu_buttons_top(txt_col, bx_col1, bx_col2, False, the_mouse, top_buttons_onoff)
        display_bj_text(BLACK)
        b1, b2 = display_middle_buttons(txt_col, bx_col1, bx_col2, False, the_mouse, middle_buttons_onoff_start,
                                        middle_buttons_onoff_ad)

        pygame.display.update()

#

# run...
if __name__ == "__main__":
    screen = pygame.display.set_mode()
    w, h = screen.get_size()
    WIDTH = w
    HEIGHT = h
    MARGIN = round(((WIDTH + HEIGHT) / 2) / 25)
    DISPLAY = (WIDTH, HEIGHT)
    # print(WIDTH, HEIGHT)
    WHITE = (255, 255, 255)
    TRANS_WHITE = (255, 255, 255, 127)
    BLACK = (0, 0, 0)
    RED = (148, 41, 41)
    GRAY = (144, 144, 144)
    TRANS_GRAY = (144, 144, 144, 127)
    TRANS_RED = (201, 83, 83, 127)
    GREEN = (33, 121, 53)  # 45, 105, 45
    DARK_GRAY = (70, 70, 70)
    CURRENT_GREEN = (87, 173, 104)  #
    WOOD = (156, 131, 90)
    YELLOW = (255, 251, 3)
    BRIGHT_PURPLE = (110, 5, 247)
    SETTINGS = 'settings.txt'
    ACCOUNTS = 'accounts.txt'
    SHOW_RED = (245, 67, 61)
    SHOW_YELLOW = (239, 245, 61)
    SHOW_GREEN = (61, 245, 104)
    # game(WHITE)
    menu()

